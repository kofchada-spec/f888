import React, { useEffect, useRef, useState } from 'react';
import mapboxgl from 'mapbox-gl';
import 'mapbox-gl/dist/mapbox-gl.css';
import { useRouteGeneration } from '@/hooks/useRouteGeneration';
import { useMapDisplay } from '@/hooks/useMapDisplay';
import { initializeMap, getMapboxToken, setupMapInteractions } from '@/utils/mapboxHelpers';
import { calculateTargetDistance, getToleranceRange, calculateDistance, calculateRouteMetrics } from '@/utils/routeCalculations';
import { PlanningData, RouteData, Coordinates } from '@/types/route';
import { useMapClickLimiter } from '@/hooks/useMapClickLimiter';

interface EnhancedMapProps {
  className?: string;
  planningData?: PlanningData;
  onRouteCalculated?: (data: RouteData) => void;
  canClick?: boolean;
  onMapClick?: () => void;
  forceReset?: boolean;
  onResetComplete?: () => void;
}

const EnhancedMap: React.FC<EnhancedMapProps> = ({ 
  className = '', 
  planningData, 
  onRouteCalculated,
  canClick = true,
  onMapClick,
  forceReset = false,
  onResetComplete
}) => {
  // Map state
  const mapContainer = useRef<HTMLDivElement>(null);
  const map = useRef<mapboxgl.Map | null>(null);
  const [mapboxToken, setMapboxToken] = useState<string | null>(null);
  const [userLocation, setUserLocation] = useState<Coordinates | null>(null);
  
  // Route generation state
  const [hasAutoGenerated, setHasAutoGenerated] = useState(false);
  const [isManualSelection, setIsManualSelection] = useState(false);
  const [firstRouteData, setFirstRouteData] = useState<RouteData | null>(null);
  const [isReset, setIsReset] = useState(false);

  // Custom hooks
  const { canClick: canClickMap } = useMapClickLimiter(3); // Allow 3 clicks max
  const { 
    generateRoundTripRoute, 
    generateOneWayRoute, 
    isCalculating, 
    routeError, 
    setRouteError 
  } = useRouteGeneration(planningData, userLocation, onRouteCalculated);
  const { displayRoundTripRoute, displayOneWayRoute, clearMap } = useMapDisplay(map);

  // Derived state for click availability
  const canActuallyClick = canClick && canClickMap && hasAutoGenerated && !isCalculating && !isReset;

  // Get Mapbox token
  useEffect(() => {
    const fetchToken = async () => {
      const token = await getMapboxToken();
      setMapboxToken(token);
    };
    fetchToken();
  }, []);

  // Get user location
  useEffect(() => {
    if (navigator.geolocation) {
      navigator.geolocation.getCurrentPosition(
        (position) => {
          setUserLocation({
            lat: position.coords.latitude,
            lng: position.coords.longitude,
          });
        },
        (error) => {
          console.warn('Geolocation failed:', error.message);
          // Don't set default location - wait for user to enable location services
          console.log('Please enable location services for accurate routes');
        }
      );
    } else {
      // No geolocation support - ask user to enable it
      console.log('Geolocation not supported by this browser');
    }
  }, []);

  // Initialize map
  useEffect(() => {
    if (!mapContainer.current || !mapboxToken || !mapboxToken.startsWith('pk.')) {
      return;
    }

    if (map.current) {
      return; // Map already initialized
    }

    console.log('Initializing map with token');
    
    const center: [number, number] = userLocation 
      ? [userLocation.lng, userLocation.lat] 
      : [2.3522, 48.8566];

    map.current = initializeMap(mapContainer.current, mapboxToken, center, 14);
    setupMapInteractions(map.current);

    // Cleanup
    return () => {
      map.current?.remove();
      map.current = null;
    };
  }, [mapboxToken, userLocation]);

  // Auto-generate route when ready - wait for real user location
  useEffect(() => {
    if (planningData && mapboxToken && userLocation && !hasAutoGenerated && !isCalculating) {
      console.log('üéØ Auto-generating route with user location:', userLocation);
      
      const autoGenerate = async () => {
        let routeData: RouteData | null = null;
        
        try {
          if (planningData.tripType === 'round-trip') {
            routeData = await generateRoundTripRoute();
          } else {
            routeData = await generateOneWayRoute();
          }

          if (routeData) {
            setFirstRouteData(routeData);
            setHasAutoGenerated(true);
            
            // Display the route
            if (planningData.tripType === 'round-trip' && routeData.routeGeoJSON) {
              displayRoundTripRoute(
                [routeData.endCoordinates.lng, routeData.endCoordinates.lat],
                routeData.routeGeoJSON,
                userLocation
              );
            } else {
              displayOneWayRoute(userLocation, routeData.endCoordinates, routeData.routeGeoJSON);
            }
          }
        } catch (error) {
          console.error('Auto-generation failed:', error);
        }
      };

      autoGenerate();
    }
  }, [planningData, userLocation, mapboxToken, hasAutoGenerated, isCalculating, generateRoundTripRoute, generateOneWayRoute, displayRoundTripRoute, displayOneWayRoute]);

  // Handle reset
  useEffect(() => {
    if (forceReset && !isReset) {
      console.log('Resetting map...');
      setIsReset(true);
      setHasAutoGenerated(false);
      setIsManualSelection(false);
      setFirstRouteData(null);
      setRouteError(null);
      clearMap();
      onResetComplete?.();
    } else if (!forceReset && isReset) {
      setIsReset(false);
    }
  }, [forceReset, isReset, onResetComplete, clearMap, setRouteError]);

  // Handle map clicks for manual route selection
  useEffect(() => {
    if (!map.current || !planningData || !userLocation) return;

    const handleMapClick = async (e: mapboxgl.MapMouseEvent) => {
      if (!canActuallyClick) return;

      console.log('Map clicked for manual route selection');
      setIsManualSelection(true);
      onMapClick?.();

      const clickedCoords = e.lngLat;
      const targetDistance = calculateTargetDistance(planningData.steps, planningData.height);
      const { min, max } = getToleranceRange(targetDistance);

        // Calculate actual distance to clicked point
        const oneWayDistance = calculateDistance(
          userLocation.lat, userLocation.lng,
          clickedCoords.lat, clickedCoords.lng
        );
        const totalDistance = planningData.tripType === 'round-trip' ? oneWayDistance * 2 : oneWayDistance;
        
        // Check if within ¬±5% tolerance
        if (totalDistance >= min && totalDistance <= max) {
          // Valid click - within tolerance
          if (planningData.tripType === 'round-trip') {
            const destCoords: [number, number] = [clickedCoords.lng, clickedCoords.lat];
            const outboundCoordinates: [number, number][] = [
              [userLocation.lng, userLocation.lat],
              [clickedCoords.lng, clickedCoords.lat]
            ];
            const returnCoordinates: [number, number][] = [
              [clickedCoords.lng, clickedCoords.lat],
              [userLocation.lng, userLocation.lat]
            ];
            const routeGeoJSON = { outboundCoordinates, returnCoordinates, samePathReturn: true };
            
            displayRoundTripRoute(destCoords, routeGeoJSON, userLocation);
            
            const metrics = calculateRouteMetrics(totalDistance, planningData);
            onRouteCalculated?.({
              distance: totalDistance,
              duration: metrics.durationMin,
              calories: metrics.calories,
              steps: metrics.steps,
              startCoordinates: userLocation,
              endCoordinates: { lat: clickedCoords.lat, lng: clickedCoords.lng },
              routeGeoJSON
            });
          } else {
            displayOneWayRoute(userLocation, { lat: clickedCoords.lat, lng: clickedCoords.lng });
            const metrics = calculateRouteMetrics(totalDistance, planningData);
            onRouteCalculated?.({
              distance: totalDistance,
              duration: metrics.durationMin,
              calories: metrics.calories,
              steps: metrics.steps,
              startCoordinates: userLocation,
              endCoordinates: { lat: clickedCoords.lat, lng: clickedCoords.lng }
            });
          }
        } else {
          // Check if within ¬±1000 steps tolerance (approximately ¬±0.7km)
          const stepsDistance = 1000 * 0.415 * planningData.height / 1000; // ~0.7km for average person
          if (Math.abs(totalDistance - targetDistance) <= stepsDistance) {
            // Propose alternative route
            console.log(`Proposing alternative route - clicked: ${totalDistance.toFixed(2)}km, target: ${targetDistance.toFixed(2)}km`);
            // Use the clicked destination but inform user it's close to objective
            if (planningData.tripType === 'round-trip') {
              const destCoords: [number, number] = [clickedCoords.lng, clickedCoords.lat];
              const outboundCoordinates: [number, number][] = [
                [userLocation.lng, userLocation.lat],
                [clickedCoords.lng, clickedCoords.lat]
              ];
              const returnCoordinates: [number, number][] = [
                [clickedCoords.lng, clickedCoords.lat],
                [userLocation.lng, userLocation.lat]
              ];
              const routeGeoJSON = { outboundCoordinates, returnCoordinates, samePathReturn: true };
              
              displayRoundTripRoute(destCoords, routeGeoJSON, userLocation);
              
              const metrics = calculateRouteMetrics(totalDistance, planningData);
              onRouteCalculated?.({
                distance: totalDistance,
                duration: metrics.durationMin,
                calories: metrics.calories,
                steps: metrics.steps,
                startCoordinates: userLocation,
                endCoordinates: { lat: clickedCoords.lat, lng: clickedCoords.lng },
                routeGeoJSON
              });
            }
          } else {
            // Clicked location is too far from objective
            const diff = totalDistance - targetDistance;
            const message = diff > 0 
              ? `L'endroit s√©lectionn√© est trop √©loign√© de votre objectif (${totalDistance.toFixed(1)}km vs ${targetDistance.toFixed(1)}km cibl√©)`
              : `L'endroit s√©lectionn√© est trop proche de votre objectif (${totalDistance.toFixed(1)}km vs ${targetDistance.toFixed(1)}km cibl√©)`;
            
            setRouteError(message);
            setTimeout(() => setRouteError(null), 4000);
          }
        }
    };

    map.current.on('click', handleMapClick);

    return () => {
      map.current?.off('click', handleMapClick);
    };
  }, [map.current, planningData, userLocation, canActuallyClick, onMapClick, onRouteCalculated, displayRoundTripRoute]);

  // Restore first route functionality
  const restoreFirstRoute = () => {
    if (firstRouteData && userLocation) {
      console.log('Restoring first route');
      setIsManualSelection(false);
      
      if (planningData?.tripType === 'round-trip' && firstRouteData.routeGeoJSON) {
        displayRoundTripRoute(
          [firstRouteData.endCoordinates.lng, firstRouteData.endCoordinates.lat],
          firstRouteData.routeGeoJSON,
          userLocation
        );
      } else {
        displayOneWayRoute(userLocation, firstRouteData.endCoordinates);
      }
      
      onRouteCalculated?.(firstRouteData);
    }
  };

  // Render loading state
  if (!mapboxToken || !mapboxToken.startsWith('pk.')) {
    return (
      <div style={{ height: '400px' }} className={`relative bg-gradient-to-br from-primary/10 to-secondary/10 rounded-2xl flex items-center justify-center ${className}`}>
        <div className="text-center max-w-md p-6">
          <div className="animate-spin rounded-full h-8 w-8 border-b-2 border-primary mx-auto mb-4"></div>
          <p className="text-sm text-muted-foreground mb-2">
            {!mapboxToken ? 'Chargement du token Mapbox...' : 'Token Mapbox invalide'}
          </p>
          <p className="text-xs text-muted-foreground">
            V√©rifiez que votre token Mapbox est configur√© dans les secrets Supabase.
          </p>
        </div>
      </div>
    );
  }

  return (
    <div className={`relative ${className}`} style={{ height: '400px' }}>
      <div 
        ref={mapContainer} 
        style={{ width: '100%', height: '100%' }}
        className="absolute inset-0 rounded-lg" 
      />
      
      {/* Loading overlay - waiting for location */}
      {!userLocation && (
        <div className="absolute inset-0 bg-black/20 backdrop-blur-sm flex items-center justify-center rounded-lg z-10">
          <div className="bg-card/90 backdrop-blur-sm p-4 rounded-lg shadow-lg">
            <div className="flex items-center space-x-3">
              <div className="animate-pulse rounded-full h-5 w-5 bg-primary/50"></div>
              <span className="text-sm font-medium">Localisation en cours...</span>
            </div>
            <p className="text-xs text-muted-foreground mt-2 text-center">Veuillez autoriser l'acc√®s √† votre position</p>
          </div>
        </div>
      )}
      
      {/* Loading overlay - route calculation */}
      {userLocation && isCalculating && (
        <div className="absolute inset-0 bg-black/20 backdrop-blur-sm flex items-center justify-center rounded-lg z-10">
          <div className="bg-card/90 backdrop-blur-sm p-4 rounded-lg shadow-lg">
            <div className="flex items-center space-x-3">
              <div className="animate-spin rounded-full h-5 w-5 border-b-2 border-primary"></div>
              <span className="text-sm font-medium">G√©n√©ration de l'itin√©raire...</span>
            </div>
          </div>
        </div>
      )}
      
      {/* Error message */}
      {routeError && (
        <div className="absolute top-4 left-4 right-4 bg-destructive/90 text-destructive-foreground p-3 rounded-lg shadow-lg z-20">
          <p className="text-sm font-medium text-center">{routeError}</p>
        </div>
      )}

      {/* Restore first route button */}
      {hasAutoGenerated && isManualSelection && firstRouteData && (
        <button
          onClick={restoreFirstRoute}
          className="absolute bottom-4 right-4 bg-primary text-primary-foreground px-4 py-2 rounded-lg shadow-lg hover:bg-primary/90 transition-colors z-10"
        >
          Revenir √† l'itin√©raire automatique
        </button>
      )}

      {/* Instructions */}
      {planningData && !routeError && !isCalculating && hasAutoGenerated && canActuallyClick && !isReset && (
        <div className="absolute bottom-4 left-4 right-4 bg-card/90 backdrop-blur-sm p-3 rounded-lg shadow-lg">
          <p className="text-sm text-center text-muted-foreground">
            {planningData.tripType === 'round-trip' 
              ? "Cliquez sur la carte pour personnaliser votre destination" 
              : "Cliquez sur la carte pour choisir une nouvelle destination"}
          </p>
        </div>
      )}
    </div>
  );
};

export default EnhancedMap;