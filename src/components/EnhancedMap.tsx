import React, { useEffect, useRef, useState } from 'react';
import mapboxgl from 'mapbox-gl';
import 'mapbox-gl/dist/mapbox-gl.css';

interface PlanningData {
  steps: string;
  pace: 'slow' | 'moderate' | 'fast';
  tripType: 'one-way' | 'round-trip';
  height: string;
  weight: string;
}

interface EnhancedMapProps {
  className?: string;
  planningData?: PlanningData;
  onRouteCalculated?: (data: {
    distance: number;
    duration: number;
    calories: number;
    steps: number;
    startCoordinates: { lat: number; lng: number };
    endCoordinates: { lat: number; lng: number };
    routeGeoJSON?: any;
  }) => void;
  canClick?: boolean;
  onMapClick?: () => void;
  forceReset?: boolean;
  onResetComplete?: () => void;
}

const EnhancedMap: React.FC<EnhancedMapProps> = ({ 
  className = '', 
  planningData, 
  onRouteCalculated,
  canClick = true,
  onMapClick,
  forceReset = false,
  onResetComplete
}) => {
  const mapContainer = useRef<HTMLDivElement>(null);
  const map = useRef<mapboxgl.Map | null>(null);
  const userMarker = useRef<mapboxgl.Marker | null>(null);
  const destinationMarker = useRef<mapboxgl.Marker | null>(null);
  
  const [mapboxToken, setMapboxToken] = useState<string | null>(null);
  const [userLocation, setUserLocation] = useState<{ lat: number; lng: number } | null>(null);
  const [permissionDenied, setPermissionDenied] = useState(false);
  const [routeError, setRouteError] = useState<string | null>(null);
  const [isCalculating, setIsCalculating] = useState(false);
  const [hasAutoGenerated, setHasAutoGenerated] = useState(false);
  const [isManualSelection, setIsManualSelection] = useState(false);
  const [defaultRoute, setDefaultRoute] = useState<any>(null);

  // Calculate target distance from steps and height
  const calculateTargetDistance = (steps: string, height: string) => {
    const stepCount = parseInt(steps);
    const heightInMeters = parseFloat(height);
    const strideLength = 0.415 * heightInMeters;
    return (stepCount * strideLength) / 1000; // km
  };

  // Calculate calories based on distance, weight, and pace
  const calculateCalories = (distanceKm: number, weight: string, pace: string) => {
    const weightKg = parseFloat(weight);
    const met = pace === 'slow' ? 3.0 : pace === 'moderate' ? 4.0 : 5.0;
    const timeHours = distanceKm / (pace === 'slow' ? 4 : pace === 'moderate' ? 5 : 6);
    return Math.round(met * weightKg * timeHours);
  };

  // Get route from Mapbox Directions API
  const getRoute = async (start: [number, number], end: [number, number]) => {
    if (!mapboxToken) return null;
    
    try {
      const response = await fetch(
        `https://api.mapbox.com/directions/v5/mapbox/walking/${start[0]},${start[1]};${end[0]},${end[1]}?geometries=geojson&access_token=${mapboxToken}`
      );
      
      if (!response.ok) throw new Error('Failed to fetch route');
      
      const data = await response.json();
      return data.routes[0];
    } catch (error) {
      console.error('Route fetch error:', error);
      return null;
    }
  };

  // Generate automatic random destination for one-way routes
  const generateRandomDestination = async () => {
    if (!planningData || !userLocation || planningData.tripType !== 'one-way') return;

    const targetDistance = calculateTargetDistance(planningData.steps, planningData.height);
    const tolerance = 0.05; // 5%
    const minDistance = targetDistance * (1 - tolerance);
    const maxDistance = targetDistance * (1 + tolerance);

    setIsCalculating(true);
    setRouteError(null);

    // Try multiple random destinations around user location
    const maxAttempts = 10;
    for (let i = 0; i < maxAttempts; i++) {
      // Generate random point within reasonable radius (roughly targetDistance * 1.2)
      const maxRadius = targetDistance * 1.2;
      const angle = Math.random() * 2 * Math.PI;
      const radius = Math.random() * maxRadius;
      
      // Convert km to approximate degrees (rough approximation)
      const latOffset = (radius * Math.cos(angle)) / 111.32; // 1 degree lat ≈ 111.32 km
      const lngOffset = (radius * Math.sin(angle)) / (111.32 * Math.cos(userLocation.lat * Math.PI / 180));
      
      const destinationCoords: [number, number] = [
        userLocation.lng + lngOffset,
        userLocation.lat + latOffset
      ];
      
      const startCoords: [number, number] = [userLocation.lng, userLocation.lat];
      const route = await getRoute(startCoords, destinationCoords);
      
      if (route) {
        const routeDistanceKm = route.distance / 1000;
        
        if (routeDistanceKm >= minDistance && routeDistanceKm <= maxDistance) {
          // Found a valid route!
          await displayRoute(destinationCoords, route, routeDistanceKm);
          setHasAutoGenerated(true);
          setIsCalculating(false);
          return;
        }
      }
    }

    // No valid route found within tolerance
    setRouteError(`Aucun itinéraire trouvé dans la tolérance de ±5% (cible: ${targetDistance.toFixed(2)}km).`);
    setIsCalculating(false);
  };

  // Generate automatic round-trip route with different outbound and return paths
  const generateRoundTripDestination = async () => {
    if (!planningData || !userLocation || planningData.tripType !== 'round-trip') return;

    const targetDistance = calculateTargetDistance(planningData.steps, planningData.height);
    const tolerance = 0.05; // 5%
    const minDistance = targetDistance * (1 - tolerance);
    const maxDistance = targetDistance * (1 + tolerance);

    setIsCalculating(true);
    setRouteError(null);

    // Try multiple random destinations for round-trip
    const maxAttempts = 15;
    for (let i = 0; i < maxAttempts; i++) {
      // Generate random point within reasonable radius (roughly targetDistance * 0.6 for half distance)
      const maxRadius = targetDistance * 0.6;
      const angle = Math.random() * 2 * Math.PI;
      const radius = Math.random() * maxRadius;
      
      // Convert km to approximate degrees
      const latOffset = (radius * Math.cos(angle)) / 111.32;
      const lngOffset = (radius * Math.sin(angle)) / (111.32 * Math.cos(userLocation.lat * Math.PI / 180));
      
      const destinationCoords: [number, number] = [
        userLocation.lng + lngOffset,
        userLocation.lat + latOffset
      ];
      
      const startCoords: [number, number] = [userLocation.lng, userLocation.lat];
      
      // Get outbound route
      const outboundRoute = await getRoute(startCoords, destinationCoords);
      if (!outboundRoute) continue;
      
      // Get return route with alternatives parameter to get different path
      const returnRoute = await getRouteWithAlternatives(destinationCoords, startCoords, outboundRoute);
      if (!returnRoute) continue;
      
      const totalDistanceKm = (outboundRoute.distance + returnRoute.distance) / 1000;
      
      if (totalDistanceKm >= minDistance && totalDistanceKm <= maxDistance) {
        // Found valid round-trip routes!
        await displayRoundTripRoute(destinationCoords, outboundRoute, returnRoute, totalDistanceKm);
        setHasAutoGenerated(true);
        setIsCalculating(false);
        return;
      }
    }

    // No valid round-trip found within tolerance  
    setRouteError(`Aucun itinéraire aller-retour trouvé dans la tolérance de ±5% (cible: ${targetDistance.toFixed(2)}km).`);
    setIsCalculating(false);
  };

  // Calculate path overlap percentage between two routes
  const calculatePathOverlap = (path1: number[][], path2: number[][]): number => {
    if (!path1 || !path2 || path1.length === 0 || path2.length === 0) return 1.0;
    
    const bufferRadius = 0.00015; // ~15m in degrees
    let overlappingSegments = 0;
    const totalSegments = Math.min(path1.length, path2.length) - 1;
    
    for (let i = 0; i < totalSegments; i++) {
      const p1Start = path1[i];
      const p1End = path1[i + 1];
      
      // Check if this segment overlaps with any segment in path2
      let hasOverlap = false;
      for (let j = 0; j < path2.length - 1; j++) {
        const p2Start = path2[j];
        const p2End = path2[j + 1];
        
        // Check if segments are close enough to be considered overlapping
        if (segmentsWithinBuffer(p1Start, p1End, p2Start, p2End, bufferRadius)) {
          hasOverlap = true;
          break;
        }
      }
      
      if (hasOverlap) overlappingSegments++;
    }
    
    return overlappingSegments / totalSegments;
  };

  // Check if two line segments are within buffer distance
  const segmentsWithinBuffer = (
    seg1Start: number[], seg1End: number[], 
    seg2Start: number[], seg2End: number[], 
    buffer: number
  ): boolean => {
    // Simplified check: distance between midpoints
    const mid1 = [(seg1Start[0] + seg1End[0]) / 2, (seg1Start[1] + seg1End[1]) / 2];
    const mid2 = [(seg2Start[0] + seg2End[0]) / 2, (seg2Start[1] + seg2End[1]) / 2];
    
    const distance = Math.sqrt(
      Math.pow(mid1[0] - mid2[0], 2) + Math.pow(mid1[1] - mid2[1], 2)
    );
    
    return distance <= buffer;
  };

  // Generate waypoints to avoid outbound path
  const generateAvoidanceWaypoints = (
    start: [number, number], 
    destination: [number, number], 
    outboundPath: number[][]
  ): [number, number][] => {
    const waypoints: [number, number][] = [];
    
    // Calculate perpendicular offset from the midpoint of outbound route
    if (outboundPath.length > 2) {
      const midIndex = Math.floor(outboundPath.length / 2);
      const midPoint = outboundPath[midIndex];
      
      // Calculate bearing from start to destination
      const bearing = Math.atan2(
        destination[1] - start[1], 
        destination[0] - start[0]
      );
      
      // Create waypoint perpendicular to the route (±90 degrees)
      const perpBearing1 = bearing + Math.PI / 2;
      const perpBearing2 = bearing - Math.PI / 2;
      
      const offset = 0.003; // ~300m in degrees
      
      const waypoint1: [number, number] = [
        midPoint[0] + Math.cos(perpBearing1) * offset,
        midPoint[1] + Math.sin(perpBearing1) * offset
      ];
      
      const waypoint2: [number, number] = [
        midPoint[0] + Math.cos(perpBearing2) * offset,
        midPoint[1] + Math.sin(perpBearing2) * offset
      ];
      
      waypoints.push(waypoint1, waypoint2);
    }
    
    return waypoints;
  };

  // Get route with 80% differentiation guarantee for return path
  const getRouteWithAlternatives = async (start: [number, number], end: [number, number], outboundRoute?: any) => {
    if (!mapboxToken) return null;
    
    try {
      // First, try getting alternatives directly
      const response = await fetch(
        `https://api.mapbox.com/directions/v5/mapbox/walking/${start[0]},${start[1]};${end[0]},${end[1]}?geometries=geojson&alternatives=true&access_token=${mapboxToken}`
      );
      
      if (!response.ok) throw new Error('Failed to fetch route');
      
      const data = await response.json();
      
      if (!data.routes || data.routes.length === 0) return null;
      
      // If we have an outbound route, find the most different alternative
      if (outboundRoute && outboundRoute.geometry && outboundRoute.geometry.coordinates) {
        let bestRoute = null;
        let minOverlap = 1.0;
        
        for (const route of data.routes) {
          const overlap = calculatePathOverlap(
            outboundRoute.geometry.coordinates,
            route.geometry.coordinates
          );
          
          console.log(`Route overlap: ${(overlap * 100).toFixed(1)}%`);
          
          if (overlap < minOverlap) {
            minOverlap = overlap;
            bestRoute = route;
          }
          
          // If we found a route with ≤30% overlap (70% different), use it
          if (overlap <= 0.30) {
            console.log(`Found route with ${((1 - overlap) * 100).toFixed(1)}% differentiation`);
            return route;
          }
        }
        
        // If no route meets 70% criteria, try waypoint routing
        if (minOverlap > 0.30) {
          console.log(`Best direct alternative only ${((1 - minOverlap) * 100).toFixed(1)}% different, trying waypoints...`);
          
          const waypoints = generateAvoidanceWaypoints(start, end, outboundRoute.geometry.coordinates);
          
          for (const waypoint of waypoints) {
            try {
              const waypointResponse = await fetch(
                `https://api.mapbox.com/directions/v5/mapbox/walking/${start[0]},${start[1]};${waypoint[0]},${waypoint[1]};${end[0]},${end[1]}?geometries=geojson&access_token=${mapboxToken}`
              );
              
              if (waypointResponse.ok) {
                const waypointData = await waypointResponse.json();
                if (waypointData.routes && waypointData.routes.length > 0) {
                  const waypointRoute = waypointData.routes[0];
                  const waypointOverlap = calculatePathOverlap(
                    outboundRoute.geometry.coordinates,
                    waypointRoute.geometry.coordinates
                  );
                  
                  console.log(`Waypoint route overlap: ${(waypointOverlap * 100).toFixed(1)}%`);
                  
                  if (waypointOverlap <= 0.30) {
                    console.log(`Waypoint route achieved ${((1 - waypointOverlap) * 100).toFixed(1)}% differentiation`);
                    return waypointRoute;
                  }
                  
                  if (waypointOverlap < minOverlap) {
                    minOverlap = waypointOverlap;
                    bestRoute = waypointRoute;
                  }
                }
              }
            } catch (waypointError) {
              console.log('Waypoint routing failed:', waypointError);
            }
          }
        }
        
        if (bestRoute) {
          console.log(`Using best available route with ${((1 - minOverlap) * 100).toFixed(1)}% differentiation`);
          return bestRoute;
        }
      }
      
      // Return the best alternative or main route
      return data.routes[1] || data.routes[0];
    } catch (error) {
      console.error('Route fetch error:', error);
      return null;
    }
  };

  // Display route on map
  const displayRoute = async (destinationCoords: [number, number], route: any, routeDistanceKm: number) => {
    if (!planningData || !userLocation) return;

    // Remove existing destination marker
    if (destinationMarker.current) {
      destinationMarker.current.remove();
    }

    // Add destination marker (red)
    destinationMarker.current = new mapboxgl.Marker({ color: '#ef4444' })
      .setLngLat(destinationCoords)
      .addTo(map.current!);

    // Add route to map
    if (map.current?.getSource('route')) {
      map.current.removeLayer('route');
      map.current.removeSource('route');
    }

    map.current?.addSource('route', {
      type: 'geojson',
      data: {
        type: 'Feature',
        properties: {},
        geometry: route.geometry
      }
    });

    map.current?.addLayer({
      id: 'route',
      type: 'line',
      source: 'route',
      layout: {
        'line-join': 'round',
        'line-cap': 'round'
      },
      paint: {
        'line-color': '#3b82f6',
        'line-width': 4
      }
    });

    // Fit map to route bounds
    const coordinates = route.geometry.coordinates;
    const bounds = coordinates.reduce((bounds: any, coord: any) => {
      return bounds.extend(coord);
    }, new mapboxgl.LngLatBounds(coordinates[0], coordinates[0]));
    
    map.current?.fitBounds(bounds, {
      padding: 50
    });

    // Calculate route data
    const calories = calculateCalories(routeDistanceKm, planningData.weight, planningData.pace);
    const durationMin = Math.round(route.duration / 60);
    
    // Calculate steps based on actual route distance instead of target steps
    const heightInMeters = parseFloat(planningData.height);
    const strideLength = 0.415 * heightInMeters;
    const steps = Math.round((routeDistanceKm * 1000) / strideLength);

    const routeData = {
      distance: routeDistanceKm,
      duration: durationMin,
      calories,
      steps,
      startCoordinates: { lat: userLocation.lat, lng: userLocation.lng },
      endCoordinates: { lat: destinationCoords[1], lng: destinationCoords[0] },
      routeGeoJSON: route.geometry
    };

    onRouteCalculated?.(routeData);
    
    // Save the first auto-generated route as default
    if (!isManualSelection && !defaultRoute) {
      setDefaultRoute({
        destinationCoords,
        route,
        routeDistanceKm,
        routeData
      });
    }
  };

  // Display round-trip route with different outbound and return paths
  const displayRoundTripRoute = async (destinationCoords: [number, number], outboundRoute: any, returnRoute: any, totalDistanceKm: number) => {
    if (!planningData || !userLocation) return;

    // Calculate differentiation percentage for user feedback
    const overlap = calculatePathOverlap(
      outboundRoute.geometry.coordinates,
      returnRoute.geometry.coordinates
    );
    const differentiation = ((1 - overlap) * 100).toFixed(0);
    
    console.log(`Round-trip routes have ${differentiation}% differentiation`);

    // Remove existing markers and routes
    if (destinationMarker.current) {
      destinationMarker.current.remove();
    }

    // Remove existing routes
    if (map.current?.getSource('outbound-route')) {
      map.current.removeLayer('outbound-route');
      map.current.removeSource('outbound-route');
    }
    if (map.current?.getSource('return-route')) {
      map.current.removeLayer('return-route');
      map.current.removeSource('return-route');
    }
    if (map.current?.getSource('route')) {
      map.current.removeLayer('route');
      map.current.removeSource('route');
    }

    // Update user marker to green
    if (userMarker.current) {
      userMarker.current.remove();
    }
    userMarker.current = new mapboxgl.Marker({ color: '#10b981' })
      .setLngLat([userLocation.lng, userLocation.lat])
      .addTo(map.current!);

    // Add destination marker (red)
    destinationMarker.current = new mapboxgl.Marker({ color: '#ef4444' })
      .setLngLat(destinationCoords)
      .addTo(map.current!);

    // Add outbound route (solid green)
    map.current?.addSource('outbound-route', {
      type: 'geojson',
      data: {
        type: 'Feature',
        properties: {},
        geometry: outboundRoute.geometry
      }
    });

    map.current?.addLayer({
      id: 'outbound-route',
      type: 'line',
      source: 'outbound-route',
      layout: {
        'line-join': 'round',
        'line-cap': 'round'
      },
      paint: {
        'line-color': '#10b981',
        'line-width': 4
      }
    });

    // Add return route (dashed blue)
    map.current?.addSource('return-route', {
      type: 'geojson',
      data: {
        type: 'Feature',
        properties: {},
        geometry: returnRoute.geometry
      }
    });

    map.current?.addLayer({
      id: 'return-route',
      type: 'line',
      source: 'return-route',
      layout: {
        'line-join': 'round',
        'line-cap': 'round'
      },
      paint: {
        'line-color': '#3b82f6',
        'line-width': 4,
        'line-dasharray': [2, 2]
      }
    });

    // Fit map to both routes bounds
    const allCoordinates = [...outboundRoute.geometry.coordinates, ...returnRoute.geometry.coordinates];
    const bounds = allCoordinates.reduce((bounds: any, coord: any) => {
      return bounds.extend(coord);
    }, new mapboxgl.LngLatBounds(allCoordinates[0], allCoordinates[0]));
    
    map.current?.fitBounds(bounds, {
      padding: 50
    });

    // Calculate route data
    const calories = calculateCalories(totalDistanceKm, planningData.weight, planningData.pace);
    const durationMin = Math.round((outboundRoute.duration + returnRoute.duration) / 60);
    const steps = parseInt(planningData.steps);

    const routeData = {
      distance: totalDistanceKm,
      duration: durationMin,
      calories,
      steps,
      startCoordinates: { lat: userLocation.lat, lng: userLocation.lng },
      endCoordinates: { lat: destinationCoords[1], lng: destinationCoords[0] },
      routeGeoJSON: {
        type: 'FeatureCollection',
        features: [
          { type: 'Feature', properties: { type: 'outbound' }, geometry: outboundRoute.geometry },
          { type: 'Feature', properties: { type: 'return' }, geometry: returnRoute.geometry }
        ]
      }
    };

    onRouteCalculated?.(routeData);
  };

  // Handle map click for destination selection
  const handleMapClick = async (e: mapboxgl.MapMouseEvent) => {
    if (!planningData || !userLocation || isCalculating || !canClick) return;
    
    setIsManualSelection(true);
    const targetDistance = calculateTargetDistance(planningData.steps, planningData.height);
    const tolerance = 0.05; // 5%
    const minDistance = targetDistance * (1 - tolerance);
    const maxDistance = targetDistance * (1 + tolerance);
    const clickTolerance = 0.30; // 300m tolerance for accepting clicks

    setIsCalculating(true);
    setRouteError(null);

    const destinationCoords: [number, number] = [e.lngLat.lng, e.lngLat.lat];
    const startCoords: [number, number] = [userLocation.lng, userLocation.lat];

    const route = await getRoute(startCoords, destinationCoords);
    
    if (!route) {
      setRouteError("Impossible de calculer l'itinéraire.");
      setIsCalculating(false);
      return;
    }

    const initialDistanceKm = route.distance / 1000;
    
    // Check if we're within click tolerance (±300m)
    if (Math.abs(initialDistanceKm - targetDistance) > clickTolerance) {
      setRouteError(`Destination trop éloignée de l'objectif (${initialDistanceKm.toFixed(2)}km). Cliquez plus près de la zone cible (~${targetDistance.toFixed(1)}km ±300m).`);
      setIsCalculating(false);
      return;
    }

    // If already within ±5% tolerance, use as-is
    if (initialDistanceKm >= minDistance && initialDistanceKm <= maxDistance) {
      await displayRoute(destinationCoords, route, initialDistanceKm);
      
      // Increment attempts only when a valid route is found
      onMapClick?.();
      
      setIsCalculating(false);
      return;
    }

    // Need to adjust: calculate direction and adjust distance to fit within ±5% range
    console.log(`Initial distance ${initialDistanceKm.toFixed(2)}km outside ±5% range. Adjusting...`);
    
    // Calculate direction from user to clicked point
    const bearing = Math.atan2(
      destinationCoords[1] - startCoords[1], 
      destinationCoords[0] - startCoords[0]
    );

    // Determine target distance within acceptable range
    let adjustedTargetDistance;
    if (initialDistanceKm < minDistance) {
      // Too short, aim for minimum acceptable distance
      adjustedTargetDistance = minDistance;
    } else {
      // Too long, aim for maximum acceptable distance
      adjustedTargetDistance = maxDistance;
    }

    // Calculate adjusted destination coordinates
    // Convert km to approximate degrees (rough approximation)
    const latOffset = (adjustedTargetDistance * Math.sin(bearing)) / 111.32; // 1 degree lat ≈ 111.32 km
    const lngOffset = (adjustedTargetDistance * Math.cos(bearing)) / (111.32 * Math.cos(userLocation.lat * Math.PI / 180));
    
    const adjustedDestination: [number, number] = [
      startCoords[0] + lngOffset,
      startCoords[1] + latOffset
    ];

    // Calculate route to adjusted destination
    const adjustedRoute = await getRoute(startCoords, adjustedDestination);
    
    if (!adjustedRoute) {
      setRouteError("Impossible de calculer l'itinéraire ajusté.");
      setIsCalculating(false);
      return;
    }

    const finalDistanceKm = adjustedRoute.distance / 1000;
    console.log(`Adjusted to ${finalDistanceKm.toFixed(2)}km (target range: ${minDistance.toFixed(2)}-${maxDistance.toFixed(2)}km)`);

    // Verify that the final route distance is still within ±5% tolerance
    if (finalDistanceKm < minDistance || finalDistanceKm > maxDistance) {
      setRouteError(`Impossible d'ajuster l'itinéraire dans la tolérance ±5% (${finalDistanceKm.toFixed(2)}km). Essayez un autre point.`);
      setIsCalculating(false);
      return;
    }

    await displayRoute(adjustedDestination, adjustedRoute, finalDistanceKm);
    
    // Increment attempts only when a valid route is found
    onMapClick?.();
    
    setIsCalculating(false);
  };

  // Get Mapbox token
  useEffect(() => {
    const fetchToken = async () => {
      try {
        const { supabase } = await import('@/integrations/supabase/client');
        const { data, error } = await supabase.functions.invoke('mapbox-token');
        
        if (error) throw error;
        if (data?.token) {
          setMapboxToken(data.token);
        }
      } catch (error) {
        console.error('Error fetching Mapbox token:', error);
      }
    };
    fetchToken();
  }, []);

  // Get user location
  useEffect(() => {
    if (navigator.geolocation) {
      navigator.geolocation.getCurrentPosition(
        (position) => {
          setUserLocation({
            lat: position.coords.latitude,
            lng: position.coords.longitude
          });
        },
        (error) => {
          console.error('Geolocation error:', error);
          setPermissionDenied(true);
          // Center on France if geolocation is denied
          setUserLocation({ lat: 46.603354, lng: 1.888334 });
        }
      );
    } else {
      // Center on France if geolocation is not available
      setUserLocation({ lat: 46.603354, lng: 1.888334 });
    }
  }, []);

  // Initialize map
  useEffect(() => {
    if (!mapContainer.current || !mapboxToken || !userLocation || map.current) return;

    mapboxgl.accessToken = mapboxToken;
    
    map.current = new mapboxgl.Map({
      container: mapContainer.current,
      style: 'mapbox://styles/mapbox/streets-v12',
      center: [userLocation.lng, userLocation.lat],
      zoom: 13
    });

    // Add navigation controls (zoom, rotate, compass)
    map.current.addControl(new mapboxgl.NavigationControl(), 'top-right');

    // Add geolocate control to find user location
    const geolocateControl = new mapboxgl.GeolocateControl({
      positionOptions: {
        enableHighAccuracy: true
      },
      trackUserLocation: false,
      showUserHeading: true
    });
    map.current.addControl(geolocateControl, 'top-right');

    // Add user marker (green) if geolocation was successful
    if (!permissionDenied) {
      userMarker.current = new mapboxgl.Marker({ color: '#10b981' })
        .setLngLat([userLocation.lng, userLocation.lat])
        .addTo(map.current);
    }

    // Add click handler for one-way routes only (if clicks are allowed)
    if (planningData && planningData.tripType === 'one-way' && canClick) {
      map.current.on('click', handleMapClick);
    }

    return () => {
      map.current?.remove();
    };
  }, [mapboxToken, userLocation, permissionDenied, planningData]);

  // Auto-generate route for one-way and round-trip
  useEffect(() => {
    if (map.current && planningData && userLocation && mapboxToken && !hasAutoGenerated && !isCalculating) {
      if (planningData.tripType === 'one-way') {
        console.log('Auto-generating random destination for one-way trip...');
        generateRandomDestination();
      } else if (planningData.tripType === 'round-trip') {
        console.log('Auto-generating round-trip route...');
        generateRoundTripDestination();
      }
    }
  }, [map.current, planningData, userLocation, mapboxToken, hasAutoGenerated, isCalculating]);

  // Handle forced reset to default route
  useEffect(() => {
    if (forceReset && defaultRoute) {
      setIsManualSelection(false);
      setRouteError(null);
      
      // Restore the original default route
      displayRoute(
        defaultRoute.destinationCoords,
        defaultRoute.route,
        defaultRoute.routeDistanceKm
      );
      
      onResetComplete?.();
    }
  }, [forceReset, defaultRoute, onResetComplete]);

  if (!mapboxToken) {
    return (
      <div className={`w-full h-[500px] bg-muted rounded-2xl flex items-center justify-center ${className}`}>
        <div className="text-center p-8">
          <div className="animate-spin rounded-full h-8 w-8 border-b-2 border-primary mx-auto mb-4"></div>
          <p className="text-muted-foreground">Chargement de la carte...</p>
        </div>
      </div>
    );
  }

  return (
    <div className={`w-full h-[500px] rounded-2xl shadow-lg relative ${className}`}>
      <div ref={mapContainer} className="w-full h-full rounded-2xl" />
      
      {/* Custom Refit to Route Button */}
      {hasAutoGenerated && (
        <button
          onClick={() => {
            if (map.current) {
              // Re-fit the map to show the current route
              const currentRoute = planningData?.tripType === 'round-trip' 
                ? map.current.getSource('outbound-route') || map.current.getSource('route')
                : map.current.getSource('route');
              
              if (currentRoute) {
                // Get bounds from current route and destination
                if (userLocation && destinationMarker.current) {
                  const bounds = new mapboxgl.LngLatBounds();
                  bounds.extend([userLocation.lng, userLocation.lat]);
                  bounds.extend(destinationMarker.current.getLngLat());
                  
                  map.current.fitBounds(bounds, {
                    padding: 80,
                    duration: 1000
                  });
                }
              }
            }
          }}
          className="absolute top-4 left-4 bg-card/90 backdrop-blur-sm hover:bg-card text-foreground p-2 rounded-lg shadow-lg transition-all hover:scale-105"
          title="Recentrer sur l'itinéraire"
        >
          <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round">
            <path d="M3 7V5a2 2 0 0 1 2-2h2"></path>
            <path d="M17 3h2a2 2 0 0 1 2 2v2"></path>
            <path d="M21 17v2a2 2 0 0 1-2 2h-2"></path>
            <path d="M7 21H5a2 2 0 0 1-2-2v-2"></path>
            <path d="M12 12l-3-3m0 0l3-3m-3 3h12"></path>
          </svg>
        </button>
      )}
      
      {/* Route Error Display */}
      {routeError && (
        <div className="absolute top-4 left-4 right-4 bg-destructive/90 backdrop-blur-sm text-destructive-foreground p-3 rounded-lg shadow-lg">
          <p className="text-sm font-medium">{routeError}</p>
        </div>
      )}
      
      {/* Calculating Indicator */}
      {isCalculating && (
        <div className="absolute inset-0 bg-background/50 backdrop-blur-sm rounded-2xl flex items-center justify-center">
          <div className="bg-card p-4 rounded-lg shadow-lg flex items-center space-x-3">
            <div className="animate-spin rounded-full h-5 w-5 border-b-2 border-primary"></div>
            <p className="text-sm font-medium">Calcul de l'itinéraire...</p>
          </div>
        </div>
      )}
      
      {/* Instructions */}
      {planningData && planningData.tripType === 'one-way' && !routeError && !isCalculating && hasAutoGenerated && canClick && !isManualSelection && (
        <div className="absolute bottom-4 left-4 right-4 bg-card/90 backdrop-blur-sm p-3 rounded-lg shadow-lg">
          <p className="text-sm text-center text-muted-foreground">
            Itinéraire généré automatiquement • Cliquez pour changer de destination
          </p>
        </div>
      )}
      
      {planningData && planningData.tripType === 'one-way' && !routeError && !isCalculating && hasAutoGenerated && !canClick && (
        <div className="absolute bottom-4 left-4 right-4 bg-card/90 backdrop-blur-sm p-3 rounded-lg shadow-lg">
          <p className="text-sm text-center text-muted-foreground">
            {isManualSelection ? 'Destination sélectionnée • Plus de clics possibles' : 'Itinéraire par défaut • Plus de clics possibles'}
          </p>
        </div>
      )}
      
      {planningData && planningData.tripType === 'one-way' && !routeError && !isCalculating && hasAutoGenerated && canClick && isManualSelection && (
        <div className="absolute bottom-4 left-4 right-4 bg-card/90 backdrop-blur-sm p-3 rounded-lg shadow-lg">
          <p className="text-sm text-center text-muted-foreground">
            Destination sélectionnée • Cliquez pour en choisir une autre
          </p>
        </div>
      )}
      
      {planningData && planningData.tripType === 'one-way' && !routeError && !isCalculating && !hasAutoGenerated && (
        <div className="absolute bottom-4 left-4 right-4 bg-card/90 backdrop-blur-sm p-3 rounded-lg shadow-lg">
          <p className="text-sm text-center text-muted-foreground">
            Génération automatique d'un itinéraire en cours...
          </p>
        </div>
      )}

      {planningData && planningData.tripType === 'round-trip' && !routeError && !isCalculating && hasAutoGenerated && (
        <div className="absolute bottom-4 left-4 right-4 bg-card/90 backdrop-blur-sm p-3 rounded-lg shadow-lg">
          <p className="text-sm text-center text-muted-foreground">
            Itinéraire aller-retour généré • <span className="text-green-600">Vert</span>: aller • <span className="text-blue-600">Bleu pointillé</span>: retour
          </p>
        </div>
      )}
      
      {planningData && planningData.tripType === 'round-trip' && !routeError && !isCalculating && !hasAutoGenerated && (
        <div className="absolute bottom-4 left-4 right-4 bg-card/90 backdrop-blur-sm p-3 rounded-lg shadow-lg">
          <p className="text-sm text-center text-muted-foreground">
            Génération automatique d'un itinéraire aller-retour...
          </p>
        </div>
      )}
    </div>
  );
};

export default EnhancedMap;