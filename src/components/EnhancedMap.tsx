import React, { useEffect, useRef, useState } from 'react';
import mapboxgl from 'mapbox-gl';
import 'mapbox-gl/dist/mapbox-gl.css';
import { useRouteGeneration } from '@/hooks/useRouteGeneration';
import { useMapDisplay } from '@/hooks/useMapDisplay';
import { initializeMap, getMapboxToken, setupMapInteractions } from '@/utils/mapboxHelpers';
import { calculateTargetDistance, getToleranceRange } from '@/utils/routeCalculations';
import { PlanningData, RouteData, Coordinates } from '@/types/route';
import { useMapClickLimiter } from '@/hooks/useMapClickLimiter';

interface EnhancedMapProps {
  className?: string;
  planningData?: PlanningData;
  onRouteCalculated?: (data: RouteData) => void;
  canClick?: boolean;
  onMapClick?: () => void;
  forceReset?: boolean;
  onResetComplete?: () => void;
}

const EnhancedMap: React.FC<EnhancedMapProps> = ({ 
  className = '', 
  planningData, 
  onRouteCalculated,
  canClick = true,
  onMapClick,
  forceReset = false,
  onResetComplete
}) => {
  // Map state
  const mapContainer = useRef<HTMLDivElement>(null);
  const map = useRef<mapboxgl.Map | null>(null);
  const [mapboxToken, setMapboxToken] = useState<string | null>(null);
  const [userLocation, setUserLocation] = useState<Coordinates | null>(null);
  
  // Route generation state
  const [hasAutoGenerated, setHasAutoGenerated] = useState(false);
  const [isManualSelection, setIsManualSelection] = useState(false);
  const [firstRouteData, setFirstRouteData] = useState<RouteData | null>(null);
  const [isReset, setIsReset] = useState(false);

  // Custom hooks
  const { canClick: canClickMap } = useMapClickLimiter(3); // Allow 3 clicks max
  const { 
    generateRoundTripRoute, 
    generateOneWayRoute, 
    isCalculating, 
    routeError, 
    setRouteError 
  } = useRouteGeneration(planningData, userLocation, onRouteCalculated);
  const { displayRoundTripRoute, displayOneWayRoute, clearMap } = useMapDisplay(map);

  // Derived state for click availability
  const canActuallyClick = canClick && canClickMap && hasAutoGenerated && !isCalculating && !isReset;

  // Get Mapbox token
  useEffect(() => {
    const fetchToken = async () => {
      const token = await getMapboxToken();
      setMapboxToken(token);
    };
    fetchToken();
  }, []);

  // Get user location
  useEffect(() => {
    if (navigator.geolocation) {
      navigator.geolocation.getCurrentPosition(
        (position) => {
          setUserLocation({
            lat: position.coords.latitude,
            lng: position.coords.longitude,
          });
        },
        (error) => {
          console.log('Geolocation error:', error);
          // Default to France center if geolocation is denied
          setUserLocation({ lat: 46.603354, lng: 1.888334 });
        }
      );
    } else {
      // Default to France center if geolocation is not available
      setUserLocation({ lat: 46.603354, lng: 1.888334 });
    }
  }, []);

  // Initialize map
  useEffect(() => {
    if (!mapContainer.current || !mapboxToken || !mapboxToken.startsWith('pk.')) {
      return;
    }

    if (map.current) {
      return; // Map already initialized
    }

    console.log('Initializing map with token');
    
    const center: [number, number] = userLocation 
      ? [userLocation.lng, userLocation.lat] 
      : [2.3522, 48.8566];

    map.current = initializeMap(mapContainer.current, mapboxToken, center, 14);
    setupMapInteractions(map.current);

    // Cleanup
    return () => {
      map.current?.remove();
      map.current = null;
    };
  }, [mapboxToken, userLocation]);

  // Auto-generate route when ready
  useEffect(() => {
    if (map.current && planningData && userLocation && mapboxToken && !hasAutoGenerated && !isCalculating) {
      const autoGenerate = async () => {
        console.log('Auto-generating route...');
        
        let routeData: RouteData | null = null;
        
        if (planningData.tripType === 'round-trip') {
          routeData = await generateRoundTripRoute();
        } else {
          routeData = await generateOneWayRoute();
        }

        if (routeData) {
          setFirstRouteData(routeData);
          setHasAutoGenerated(true);
          
          // Display the route
          if (planningData.tripType === 'round-trip' && routeData.routeGeoJSON) {
            displayRoundTripRoute(
              [routeData.endCoordinates.lng, routeData.endCoordinates.lat],
              routeData.routeGeoJSON,
              userLocation
            );
          } else {
            displayOneWayRoute(userLocation, routeData.endCoordinates);
          }
        }
      };

      autoGenerate();
    }
  }, [map.current, planningData, userLocation, mapboxToken, hasAutoGenerated, isCalculating, generateRoundTripRoute, generateOneWayRoute, displayRoundTripRoute, displayOneWayRoute]);

  // Handle reset
  useEffect(() => {
    if (forceReset && !isReset) {
      console.log('Resetting map...');
      setIsReset(true);
      setHasAutoGenerated(false);
      setIsManualSelection(false);
      setFirstRouteData(null);
      setRouteError(null);
      clearMap();
      onResetComplete?.();
    } else if (!forceReset && isReset) {
      setIsReset(false);
    }
  }, [forceReset, isReset, onResetComplete, clearMap, setRouteError]);

  // Handle map clicks for manual route selection
  useEffect(() => {
    if (!map.current || !planningData || !userLocation) return;

    const handleMapClick = async (e: mapboxgl.MapMouseEvent) => {
      if (!canActuallyClick) return;

      console.log('Map clicked for manual route selection');
      setIsManualSelection(true);
      onMapClick?.();

      const clickedCoords = e.lngLat;
      const targetDistance = calculateTargetDistance(planningData.steps, planningData.height);
      const { min, max } = getToleranceRange(targetDistance);

      // For round-trip, generate route with clicked destination
      if (planningData.tripType === 'round-trip') {
        // Simplified click handling - just display a route to the clicked point
        const destCoords: [number, number] = [clickedCoords.lng, clickedCoords.lat];
        
        // Create simple round-trip coordinates
        const outboundCoordinates: [number, number][] = [
          [userLocation.lng, userLocation.lat],
          [clickedCoords.lng, clickedCoords.lat]
        ];
        
        const returnCoordinates: [number, number][] = [
          [clickedCoords.lng, clickedCoords.lat],
          [userLocation.lng, userLocation.lat]
        ];

        const routeGeoJSON = { outboundCoordinates, returnCoordinates, samePathReturn: true };
        
        displayRoundTripRoute(destCoords, routeGeoJSON, userLocation);
        
        // Calculate approximate distance for clicked route
        const distance = targetDistance; // Use target for simplicity
        const calories = planningData.pace === 'slow' ? distance * 50 : planningData.pace === 'moderate' ? distance * 60 : distance * 70;
        const duration = Math.round((distance / (planningData.pace === 'slow' ? 4 : planningData.pace === 'moderate' ? 5 : 6)) * 60);
        
        onRouteCalculated?.({
          distance,
          duration,
          calories: Math.round(calories),
          steps: parseInt(planningData.steps),
          startCoordinates: userLocation,
          endCoordinates: { lat: clickedCoords.lat, lng: clickedCoords.lng },
          routeGeoJSON
        });
      }
    };

    map.current.on('click', handleMapClick);

    return () => {
      map.current?.off('click', handleMapClick);
    };
  }, [map.current, planningData, userLocation, canActuallyClick, onMapClick, onRouteCalculated, displayRoundTripRoute]);

  // Restore first route functionality
  const restoreFirstRoute = () => {
    if (firstRouteData && userLocation) {
      console.log('Restoring first route');
      setIsManualSelection(false);
      
      if (planningData?.tripType === 'round-trip' && firstRouteData.routeGeoJSON) {
        displayRoundTripRoute(
          [firstRouteData.endCoordinates.lng, firstRouteData.endCoordinates.lat],
          firstRouteData.routeGeoJSON,
          userLocation
        );
      } else {
        displayOneWayRoute(userLocation, firstRouteData.endCoordinates);
      }
      
      onRouteCalculated?.(firstRouteData);
    }
  };

  // Render loading state
  if (!mapboxToken || !mapboxToken.startsWith('pk.')) {
    return (
      <div style={{ height: '400px' }} className={`relative bg-gradient-to-br from-primary/10 to-secondary/10 rounded-2xl flex items-center justify-center ${className}`}>
        <div className="text-center max-w-md p-6">
          <div className="animate-spin rounded-full h-8 w-8 border-b-2 border-primary mx-auto mb-4"></div>
          <p className="text-sm text-muted-foreground mb-2">
            {!mapboxToken ? 'Chargement du token Mapbox...' : 'Token Mapbox invalide'}
          </p>
          <p className="text-xs text-muted-foreground">
            Vérifiez que votre token Mapbox est configuré dans les secrets Supabase.
          </p>
        </div>
      </div>
    );
  }

  return (
    <div className={`relative ${className}`} style={{ height: '400px' }}>
      <div 
        ref={mapContainer} 
        style={{ width: '100%', height: '100%' }}
        className="absolute inset-0 rounded-lg" 
      />
      
      {/* Loading overlay */}
      {isCalculating && (
        <div className="absolute inset-0 bg-black/20 backdrop-blur-sm flex items-center justify-center rounded-lg z-10">
          <div className="bg-card/90 backdrop-blur-sm p-4 rounded-lg shadow-lg">
            <div className="flex items-center space-x-3">
              <div className="animate-spin rounded-full h-5 w-5 border-b-2 border-primary"></div>
              <span className="text-sm font-medium">Génération de l'itinéraire...</span>
            </div>
          </div>
        </div>
      )}
      
      {/* Error message */}
      {routeError && (
        <div className="absolute top-4 left-4 right-4 bg-destructive/90 text-destructive-foreground p-3 rounded-lg shadow-lg z-20">
          <p className="text-sm font-medium text-center">{routeError}</p>
        </div>
      )}

      {/* Restore first route button */}
      {hasAutoGenerated && isManualSelection && firstRouteData && (
        <button
          onClick={restoreFirstRoute}
          className="absolute bottom-4 right-4 bg-primary text-primary-foreground px-4 py-2 rounded-lg shadow-lg hover:bg-primary/90 transition-colors z-10"
        >
          Revenir à l'itinéraire automatique
        </button>
      )}

      {/* Instructions */}
      {planningData && !routeError && !isCalculating && hasAutoGenerated && canActuallyClick && !isReset && (
        <div className="absolute bottom-4 left-4 right-4 bg-card/90 backdrop-blur-sm p-3 rounded-lg shadow-lg">
          <p className="text-sm text-center text-muted-foreground">
            {planningData.tripType === 'round-trip' 
              ? "Cliquez sur la carte pour personnaliser votre destination" 
              : "Cliquez sur la carte pour choisir une nouvelle destination"}
          </p>
        </div>
      )}
    </div>
  );
};

export default EnhancedMap;