import React, { useEffect, useRef, useState } from 'react';
import mapboxgl from 'mapbox-gl';
import 'mapbox-gl/dist/mapbox-gl.css';

interface PlanningData {
  steps: string;
  pace: 'slow' | 'moderate' | 'fast';
  tripType: 'one-way' | 'round-trip';
  height: string;
  weight: string;
}

interface EnhancedMapProps {
  className?: string;
  planningData?: PlanningData;
  onRouteCalculated?: (data: {
    distance: number;
    duration: number;
    calories: number;
    steps: number;
    startCoordinates: { lat: number; lng: number };
    endCoordinates: { lat: number; lng: number };
    routeGeoJSON?: any;
  }) => void;
  canClick?: boolean;
  onMapClick?: () => void;
  forceReset?: boolean;
  onResetComplete?: () => void;
}

const EnhancedMap: React.FC<EnhancedMapProps> = ({ 
  className = '', 
  planningData, 
  onRouteCalculated,
  canClick = true,
  onMapClick,
  forceReset = false,
  onResetComplete
}) => {
  const mapContainer = useRef<HTMLDivElement>(null);
  const map = useRef<mapboxgl.Map | null>(null);
  const userMarker = useRef<mapboxgl.Marker | null>(null);
  const destinationMarker = useRef<mapboxgl.Marker | null>(null);
  
  const [mapboxToken, setMapboxToken] = useState<string | null>(null);
  const [userLocation, setUserLocation] = useState<{ lat: number; lng: number } | null>(null);
  const [permissionDenied, setPermissionDenied] = useState(false);
  const [routeError, setRouteError] = useState<string | null>(null);
  const [isCalculating, setIsCalculating] = useState(false);
  const [hasAutoGenerated, setHasAutoGenerated] = useState(false);
  const [isManualSelection, setIsManualSelection] = useState(false);
  const [firstRouteData, setFirstRouteData] = useState<any>(null); // Stocker le premier itin√©raire
  const [isReset, setIsReset] = useState(false); // Mode r√©initialis√© (clics d√©sactiv√©s)
  

  // Calculate target distance from steps and height
  const calculateTargetDistance = (steps: string, height: string) => {
    const stepCount = parseInt(steps);
    const heightInMeters = parseFloat(height);
    const strideLength = 0.415 * heightInMeters;
    return (stepCount * strideLength) / 1000; // km
  };

  // Calculate calories based on distance, weight, and pace
  const calculateCalories = (distanceKm: number, weight: string, pace: string) => {
    const weightKg = parseFloat(weight);
    const met = pace === 'slow' ? 3.0 : pace === 'moderate' ? 4.0 : 5.0;
    const timeHours = distanceKm / (pace === 'slow' ? 4 : pace === 'moderate' ? 5 : 6);
    return Math.round(met * weightKg * timeHours);
  };

  // Calculate distance between two coordinates in km using Haversine formula
  const calculateDistance = (lat1: number, lng1: number, lat2: number, lng2: number): number => {
    const R = 6371; // Radius of the Earth in km
    const dLat = (lat2 - lat1) * Math.PI / 180;
    const dLng = (lng2 - lng1) * Math.PI / 180;
    const a = 
      Math.sin(dLat / 2) * Math.sin(dLat / 2) +
      Math.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) * 
      Math.sin(dLng / 2) * Math.sin(dLng / 2);
    const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
    return R * c;
  };

  // Get route from Mapbox Directions API (DISABLED - using default routes)
  const getRoute = async (start: [number, number], end: [number, number]) => {
    // D√©sactiv√© pour √©viter les erreurs de rate limiting
    console.log('üö´ Requ√™te API Mapbox d√©sactiv√©e, utilisation d\'itin√©raires par d√©faut');
    return null;
  };

  // Generate automatic random destination for one-way routes
  const generateRandomDestination = async () => {
    if (!planningData || !userLocation || planningData.tripType !== 'one-way') return;

    const targetDistance = calculateTargetDistance(planningData.steps, planningData.height);
    const tolerance = 0.05; // 5%
    const minDistance = targetDistance * (1 - tolerance);
    const maxDistance = targetDistance * (1 + tolerance);

    setIsCalculating(true);
    setRouteError(null);

    // Try multiple random destinations around user location
    const maxAttempts = 10;
    for (let i = 0; i < maxAttempts; i++) {
      // Generate random point within reasonable radius (roughly targetDistance * 1.2)
      const maxRadius = targetDistance * 1.2;
      const angle = Math.random() * 2 * Math.PI;
      const radius = Math.random() * maxRadius;
      
      // Convert km to approximate degrees (rough approximation)
      const latOffset = (radius * Math.cos(angle)) / 111.32; // 1 degree lat ‚âà 111.32 km
      const lngOffset = (radius * Math.sin(angle)) / (111.32 * Math.cos(userLocation.lat * Math.PI / 180));
      
      const destinationCoords: [number, number] = [
        userLocation.lng + lngOffset,
        userLocation.lat + latOffset
      ];
      
      const startCoords: [number, number] = [userLocation.lng, userLocation.lat];
      const route = await getRoute(startCoords, destinationCoords);
      
      if (route) {
        const routeDistanceKm = route.distance / 1000;
        
        if (routeDistanceKm >= minDistance && routeDistanceKm <= maxDistance) {
          // Found a valid route!
          await displayRoute(destinationCoords, route, routeDistanceKm);
          setHasAutoGenerated(true);
          setIsCalculating(false);
          return;
        }
      }
    }

    // No valid route found within tolerance
    setRouteError(`Aucun itin√©raire trouv√© dans la tol√©rance de ¬±5% (cible: ${targetDistance.toFixed(2)}km).`);
    setIsCalculating(false);
  };

  // Generate automatic round-trip route with ¬±5% tolerance validation (NO API CALLS)
  const generateRoundTripDestination = async () => {
    if (!planningData || !userLocation || planningData.tripType !== 'round-trip') return;

    const targetDistance = calculateTargetDistance(planningData.steps, planningData.height);
    const tolerance = 0.05; // 5%
    const minDistance = targetDistance * (1 - tolerance);
    const maxDistance = targetDistance * (1 + tolerance);
    
    setIsCalculating(true);
    setRouteError(null);

    console.log(`üéØ G√©n√©ration itin√©raire aller-retour - cible: ${targetDistance.toFixed(2)}km (¬±5% = ${minDistance.toFixed(2)}-${maxDistance.toFixed(2)}km)`);

    const maxAttempts = 20; // Augmentation des tentatives
    let attempt = 0;
    let bestRoute = null;
    let bestDifference = Infinity;

    while (attempt < maxAttempts) {
      attempt++;
      console.log(`Tentative ${attempt}/${maxAttempts}...`);

      try {
        // G√©n√©rer une destination avec une approche plus intelligente
        // Commencer proche de la distance cible et ajuster progressivement
        const baseAngle = Math.random() * 2 * Math.PI;
        
        // Viser directement la distance cible avec une petite variation
        const targetOutboundKm = targetDistance * 0.4; // 40% pour l'aller
        const targetReturnKm = targetDistance * 0.6; // 60% pour le retour (avec d√©tour)
        
        // Convertir en degr√©s approximatifs
        const outboundDistanceDegrees = targetOutboundKm / 111.32;
        
        const destLat = userLocation.lat + Math.sin(baseAngle) * outboundDistanceDegrees;
        const destLng = userLocation.lng + Math.cos(baseAngle) * outboundDistanceDegrees / Math.cos(userLocation.lat * Math.PI / 180);
        
        // Cr√©er l'itin√©raire aller (ligne droite)
        const outboundCoordinates: [number, number][] = [
          [userLocation.lng, userLocation.lat],
          [destLng, destLat]
        ];
        
        // Cr√©er l'itin√©raire retour avec un d√©tour calcul√© pour atteindre la distance cible
        const returnAngle = baseAngle + Math.PI + (Math.random() - 0.5) * 0.8; // Angle oppos√© avec variation
        const detourDistanceDegrees = (targetReturnKm - targetOutboundKm) / 111.32;
        
        const waypointLat = destLat + Math.sin(returnAngle) * detourDistanceDegrees * 0.3;
        const waypointLng = destLng + Math.cos(returnAngle) * detourDistanceDegrees * 0.3 / Math.cos(destLat * Math.PI / 180);
        
        const returnCoordinates: [number, number][] = [
          [destLng, destLat],
          [waypointLng, waypointLat],
          [userLocation.lng, userLocation.lat]
        ];

        // Calculer la distance r√©elle des segments
        const outboundDistanceKm = calculateDistance(
          userLocation.lat, userLocation.lng, 
          destLat, destLng
        );
        
        const returnSegment1Km = calculateDistance(
          destLat, destLng,
          waypointLat, waypointLng
        );
        
        const returnSegment2Km = calculateDistance(
          waypointLat, waypointLng,
          userLocation.lat, userLocation.lng
        );
        
        const totalCalculatedDistance = outboundDistanceKm + returnSegment1Km + returnSegment2Km;
        const difference = Math.abs(totalCalculatedDistance - targetDistance);
        
        console.log(`Tentative ${attempt}: Distance = ${totalCalculatedDistance.toFixed(2)}km (diff: ${difference.toFixed(2)}km)`);

        // Sauvegarder la meilleure option
        if (difference < bestDifference) {
          bestDifference = difference;
          bestRoute = {
            outboundCoordinates,
            returnCoordinates,
            totalDistance: totalCalculatedDistance,
            destLat,
            destLng,
            outboundDistanceKm,
            returnDistanceKm: returnSegment1Km + returnSegment2Km
          };
        }

        // V√©rifier si la distance respecte la tol√©rance ¬±5%
        if (totalCalculatedDistance >= minDistance && totalCalculatedDistance <= maxDistance) {
          console.log(`‚úÖ Itin√©raire valide trouv√© √† la tentative ${attempt} (${totalCalculatedDistance.toFixed(2)}km)`);
          
          await createAndDisplayRoute(bestRoute);
          setHasAutoGenerated(true);
          setIsCalculating(false);
          return;
        }

      } catch (error) {
        console.error(`Erreur tentative ${attempt}:`, error);
      }
    }

    // Si aucun itin√©raire parfait, utiliser le meilleur trouv√© si la diff√©rence est raisonnable (¬±10%)
    if (bestRoute && bestDifference <= targetDistance * 0.10) {
      console.log(`‚ö†Ô∏è Utilisation du meilleur itin√©raire trouv√© (diff√©rence: ${bestDifference.toFixed(2)}km)`);
      await createAndDisplayRoute(bestRoute);
      setHasAutoGenerated(true);
      setIsCalculating(false);
      return;
    }

    // Aucun itin√©raire valide trouv√©
    console.log(`‚ùå Aucun itin√©raire acceptable apr√®s ${maxAttempts} tentatives (meilleure diff: ${bestDifference.toFixed(2)}km)`);
    setRouteError(`Aucun itin√©raire trouv√© dans la plage ¬±5% (${minDistance.toFixed(1)}-${maxDistance.toFixed(1)}km). Essayez de modifier vos param√®tres de pas ou de taille.`);
    setIsCalculating(false);
  };

  // Fonction helper pour cr√©er et afficher une route
  const createAndDisplayRoute = async (routeData: any) => {
    const { outboundCoordinates, returnCoordinates, totalDistance, destLat, destLng, outboundDistanceKm, returnDistanceKm } = routeData;
    
    // Calculer les m√©triques
    const calories = calculateCalories(totalDistance, planningData!.weight, planningData!.pace);
    const speed = planningData!.pace === 'slow' ? 4 : planningData!.pace === 'moderate' ? 5 : 6;
    const durationMin = Math.round((totalDistance / speed) * 60);
    const steps = Math.round((totalDistance * 1000) / (0.415 * parseFloat(planningData!.height)));

    // Envoyer les donn√©es de route
    if (onRouteCalculated) {
      onRouteCalculated({
        distance: totalDistance,
        duration: durationMin,
        calories,
        steps,
        startCoordinates: { lat: userLocation!.lat, lng: userLocation!.lng },
        endCoordinates: { lat: destLat, lng: destLng },
        routeGeoJSON: {
          outboundCoordinates,
          returnCoordinates,
          samePathReturn: false
        }
      });
    }

    // Afficher la route sur la carte
    const destCoords: [number, number] = [destLng, destLat];
    
    const outboundRoute = {
      geometry: { coordinates: outboundCoordinates },
      distance: outboundDistanceKm * 1000
    };
    
    const returnRoute = {
      geometry: { coordinates: returnCoordinates },
      distance: returnDistanceKm * 1000
    };
    
    await displayRoundTripRoute(destCoords, outboundRoute, returnRoute, totalDistance);
    
    console.log(`‚úÖ Route affich√©e: ${totalDistance.toFixed(2)}km (${steps} pas)`);
  };

  // Calculate path overlap percentage between two routes
  const calculatePathOverlap = (path1: number[][], path2: number[][]): number => {
    if (!path1 || !path2 || path1.length === 0 || path2.length === 0) return 1.0;
    
    const bufferRadius = 0.00015; // ~15m in degrees
    let overlappingSegments = 0;
    const totalSegments = Math.min(path1.length, path2.length) - 1;
    
    for (let i = 0; i < totalSegments; i++) {
      const p1Start = path1[i];
      const p1End = path1[i + 1];
      
      // Check if this segment overlaps with any segment in path2
      let hasOverlap = false;
      for (let j = 0; j < path2.length - 1; j++) {
        const p2Start = path2[j];
        const p2End = path2[j + 1];
        
        // Check if segments are close enough to be considered overlapping
        if (segmentsWithinBuffer(p1Start, p1End, p2Start, p2End, bufferRadius)) {
          hasOverlap = true;
          break;
        }
      }
      
      if (hasOverlap) overlappingSegments++;
    }
    
    return overlappingSegments / totalSegments;
  };

  // Check if two line segments are within buffer distance
  const segmentsWithinBuffer = (
    seg1Start: number[], seg1End: number[], 
    seg2Start: number[], seg2End: number[], 
    buffer: number
  ): boolean => {
    // Simplified check: distance between midpoints
    const mid1 = [(seg1Start[0] + seg1End[0]) / 2, (seg1Start[1] + seg1End[1]) / 2];
    const mid2 = [(seg2Start[0] + seg2End[0]) / 2, (seg2Start[1] + seg2End[1]) / 2];
    
    const distance = Math.sqrt(
      Math.pow(mid1[0] - mid2[0], 2) + Math.pow(mid1[1] - mid2[1], 2)
    );
    
    return distance <= buffer;
  };

  // Generate waypoints to avoid outbound path
  const generateAvoidanceWaypoints = (
    start: [number, number], 
    destination: [number, number], 
    outboundPath: number[][]
  ): [number, number][] => {
    const waypoints: [number, number][] = [];
    
    // Calculate perpendicular offset from the midpoint of outbound route
    if (outboundPath.length > 2) {
      const midIndex = Math.floor(outboundPath.length / 2);
      const midPoint = outboundPath[midIndex];
      
      // Calculate bearing from start to destination
      const bearing = Math.atan2(
        destination[1] - start[1], 
        destination[0] - start[0]
      );
      
      // Create waypoint perpendicular to the route (¬±90 degrees)
      const perpBearing1 = bearing + Math.PI / 2;
      const perpBearing2 = bearing - Math.PI / 2;
      
      const offset = 0.003; // ~300m in degrees
      
      const waypoint1: [number, number] = [
        midPoint[0] + Math.cos(perpBearing1) * offset,
        midPoint[1] + Math.sin(perpBearing1) * offset
      ];
      
      const waypoint2: [number, number] = [
        midPoint[0] + Math.cos(perpBearing2) * offset,
        midPoint[1] + Math.sin(perpBearing2) * offset
      ];
      
      waypoints.push(waypoint1, waypoint2);
    }
    
    return waypoints;
  };

  // Get route with differentiation guarantee for return path (optimized for speed)
  const getRouteWithAlternatives = async (start: [number, number], end: [number, number], outboundRoute?: any, differentiationThreshold: number = 0.25) => {
    if (!mapboxToken) return null;
    
    try {
      // First, try getting alternatives directly
      const response = await fetch(
        `https://api.mapbox.com/directions/v5/mapbox/walking/${start[0]},${start[1]};${end[0]},${end[1]}?geometries=geojson&alternatives=true&access_token=${mapboxToken}`
      );
      
      if (!response.ok) throw new Error('Failed to fetch route');
      
      const data = await response.json();
      
      if (!data.routes || data.routes.length === 0) return null;
      
      // If we have an outbound route, find the most different alternative
      if (outboundRoute && outboundRoute.geometry && outboundRoute.geometry.coordinates) {
        let bestRoute = null;
        let minOverlap = 1.0;
        const maxOverlap = 1 - differentiationThreshold; // Convert differentiation to overlap threshold
        
        for (const route of data.routes) {
          const overlap = calculatePathOverlap(
            outboundRoute.geometry.coordinates,
            route.geometry.coordinates
          );
          
          console.log(`Route overlap: ${(overlap * 100).toFixed(1)}% (threshold: ${(maxOverlap * 100).toFixed(0)}%)`);
          
          if (overlap < minOverlap) {
            minOverlap = overlap;
            bestRoute = route;
          }
          
          // If we found a route with sufficient differentiation, use it
          if (overlap <= maxOverlap) {
            console.log(`Found route with ${((1 - overlap) * 100).toFixed(1)}% differentiation`);
            return route;
          }
        }
        
        // Quick waypoint attempt (limit to 2 waypoints max for speed)
        if (minOverlap > maxOverlap && minOverlap > 0.8) { // Only try waypoints if routes are very similar
          console.log(`Routes too similar (${((1 - minOverlap) * 100).toFixed(1)}% different), trying 2 quick waypoints...`);
          
          const waypoints = generateAvoidanceWaypoints(start, end, outboundRoute.geometry.coordinates).slice(0, 2); // Limit to 2 waypoints
          
          for (const waypoint of waypoints) {
            try {
              const waypointResponse = await fetch(
                `https://api.mapbox.com/directions/v5/mapbox/walking/${start[0]},${start[1]};${waypoint[0]},${waypoint[1]};${end[0]},${end[1]}?geometries=geojson&access_token=${mapboxToken}`
              );
              
              if (waypointResponse.ok) {
                const waypointData = await waypointResponse.json();
                if (waypointData.routes && waypointData.routes.length > 0) {
                  const waypointRoute = waypointData.routes[0];
                  const waypointOverlap = calculatePathOverlap(
                    outboundRoute.geometry.coordinates,
                    waypointRoute.geometry.coordinates
                  );
                  
                  console.log(`Waypoint route overlap: ${(waypointOverlap * 100).toFixed(1)}%`);
                  
                  if (waypointOverlap <= maxOverlap) {
                    console.log(`Waypoint route achieved ${((1 - waypointOverlap) * 100).toFixed(1)}% differentiation`);
                    return waypointRoute;
                  }
                  
                  if (waypointOverlap < minOverlap) {
                    minOverlap = waypointOverlap;
                    bestRoute = waypointRoute;
                  }
                }
              }
            } catch (waypointError) {
              // Silently continue to next waypoint
            }
          }
        }
        
        // Accept best available route even if not perfectly differentiated
        if (bestRoute && minOverlap < 0.95) { // Accept if at least 5% different
          console.log(`Using best available route with ${((1 - minOverlap) * 100).toFixed(1)}% differentiation`);
          return bestRoute;
        }
      }
      
      // Return the best alternative or main route
      return data.routes[1] || data.routes[0];
    } catch (error) {
      console.error('Route fetch error:', error);
      return null;
    }
  };

  // Display route on map
  const displayRoute = async (destinationCoords: [number, number], route: any, routeDistanceKm: number) => {
    if (!planningData || !userLocation) return;

    // Remove existing destination marker
    if (destinationMarker.current) {
      destinationMarker.current.remove();
    }

    // Add destination marker (red)
    destinationMarker.current = new mapboxgl.Marker({ color: '#ef4444' })
      .setLngLat(destinationCoords)
      .addTo(map.current!);

    // Add route to map
    if (map.current?.getSource('route')) {
      map.current.removeLayer('route');
      map.current.removeSource('route');
    }

    map.current?.addSource('route', {
      type: 'geojson',
      data: {
        type: 'Feature',
        properties: {},
        geometry: route.geometry
      }
    });

    map.current?.addLayer({
      id: 'route',
      type: 'line',
      source: 'route',
      layout: {
        'line-join': 'round',
        'line-cap': 'round'
      },
      paint: {
        'line-color': '#3b82f6',
        'line-width': 4
      }
    });

    // Fit map to route bounds
    const coordinates = route.geometry.coordinates;
    const bounds = coordinates.reduce((bounds: any, coord: any) => {
      return bounds.extend(coord);
    }, new mapboxgl.LngLatBounds(coordinates[0], coordinates[0]));
    
    map.current?.fitBounds(bounds, {
      padding: 50
    });

    // Calculate route data
    const calories = calculateCalories(routeDistanceKm, planningData.weight, planningData.pace);
    const durationMin = Math.round(route.duration / 60);
    
    // Calculate steps based on actual route distance instead of target steps
    const heightInMeters = parseFloat(planningData.height);
    const strideLength = 0.415 * heightInMeters;
    const steps = Math.round((routeDistanceKm * 1000) / strideLength);

    const routeData = {
      distance: routeDistanceKm,
      duration: durationMin,
      calories,
      steps,
      startCoordinates: { lat: userLocation.lat, lng: userLocation.lng },
      endCoordinates: { lat: destinationCoords[1], lng: destinationCoords[0] },
      routeGeoJSON: route.geometry
    };

    // Sauvegarder le premier itin√©raire g√©n√©r√© automatiquement (pas de s√©lection manuelle)
    if (!isManualSelection && !firstRouteData) {
      setFirstRouteData(routeData);
      console.log('Premier itin√©raire sauvegard√©');
    }

    onRouteCalculated?.(routeData);
  };

  // Display round-trip route with different outbound and return paths
  const displayRoundTripRoute = async (destinationCoords: [number, number], outboundRoute: any, returnRoute: any, totalDistanceKm: number) => {
    if (!planningData || !userLocation) {
      console.log('‚ùå displayRoundTripRoute: Missing planningData or userLocation');
      return;
    }

    if (!map.current) {
      console.log('‚ùå displayRoundTripRoute: Map not available');
      return;
    }

    if (!map.current.isStyleLoaded()) {
      console.log('‚è≥ displayRoundTripRoute: Map style not loaded, waiting...');
      map.current.once('styledata', () => {
        if (map.current?.isStyleLoaded()) {
          displayRoundTripRoute(destinationCoords, outboundRoute, returnRoute, totalDistanceKm);
        }
      });
      return;
    }

    console.log('üó∫Ô∏è displayRoundTripRoute appel√©e:', {
      destinationCoords,
      outboundCoordinates: outboundRoute?.geometry?.coordinates?.length,
      returnCoordinates: returnRoute?.geometry?.coordinates?.length,
      totalDistanceKm
    });

    // Calculate differentiation percentage for user feedback
    const overlap = calculatePathOverlap(
      outboundRoute.geometry.coordinates,
      returnRoute.geometry.coordinates
    );
    const differentiation = ((1 - overlap) * 100).toFixed(0);
    
    console.log(`Round-trip routes have ${differentiation}% differentiation`);

    // Remove existing markers and routes
    if (destinationMarker.current) {
      destinationMarker.current.remove();
    }

    // Remove existing routes
    if (map.current?.getSource('outbound-route')) {
      map.current.removeLayer('outbound-route');
      map.current.removeSource('outbound-route');
    }
    if (map.current?.getSource('return-route')) {
      map.current.removeLayer('return-route');
      map.current.removeSource('return-route');
    }
    if (map.current?.getSource('route')) {
      map.current.removeLayer('route');
      map.current.removeSource('route');
    }

    // Update user marker to green
    if (userMarker.current) {
      userMarker.current.remove();
    }
    userMarker.current = new mapboxgl.Marker({ color: '#10b981' })
      .setLngLat([userLocation.lng, userLocation.lat])
      .addTo(map.current!);

    // Add destination marker (red)
    destinationMarker.current = new mapboxgl.Marker({ color: '#ef4444' })
      .setLngLat(destinationCoords)
      .addTo(map.current!);

    // Add outbound route (solid green)
    map.current?.addSource('outbound-route', {
      type: 'geojson',
      data: {
        type: 'Feature',
        properties: {},
        geometry: outboundRoute.geometry
      }
    });

    map.current?.addLayer({
      id: 'outbound-route',
      type: 'line',
      source: 'outbound-route',
      layout: {
        'line-join': 'round',
        'line-cap': 'round'
      },
      paint: {
        'line-color': '#10b981',
        'line-width': 4
      }
    });

    // Add return route (dashed blue)
    map.current?.addSource('return-route', {
      type: 'geojson',
      data: {
        type: 'Feature',
        properties: {},
        geometry: returnRoute.geometry
      }
    });

    map.current?.addLayer({
      id: 'return-route',
      type: 'line',
      source: 'return-route',
      layout: {
        'line-join': 'round',
        'line-cap': 'round'
      },
      paint: {
        'line-color': '#3b82f6',
        'line-width': 4,
        'line-dasharray': [2, 2]
      }
    });

    // Fit map to both routes bounds
    const allCoordinates = [...outboundRoute.geometry.coordinates, ...returnRoute.geometry.coordinates];
    const bounds = allCoordinates.reduce((bounds: any, coord: any) => {
      return bounds.extend(coord);
    }, new mapboxgl.LngLatBounds(allCoordinates[0], allCoordinates[0]));
    
    map.current?.fitBounds(bounds, {
      padding: 50
    });

    // Calculate route data
    const calories = calculateCalories(totalDistanceKm, planningData.weight, planningData.pace);
    const durationMin = Math.round((outboundRoute.duration + returnRoute.duration) / 60);
    const steps = parseInt(planningData.steps);

    const routeData = {
      distance: totalDistanceKm,
      duration: durationMin,
      calories,
      steps,
      startCoordinates: { lat: userLocation.lat, lng: userLocation.lng },
      endCoordinates: { lat: destinationCoords[1], lng: destinationCoords[0] },
      routeGeoJSON: {
        type: 'FeatureCollection',
        features: [
          { type: 'Feature', properties: { type: 'outbound' }, geometry: outboundRoute.geometry },
          { type: 'Feature', properties: { type: 'return' }, geometry: returnRoute.geometry }
        ]
      }
    };

    // Sauvegarder le premier itin√©raire aller-retour g√©n√©r√© automatiquement
    if (!isManualSelection && !firstRouteData) {
      setFirstRouteData(routeData);
      console.log('Premier itin√©raire aller-retour sauvegard√©');
    }

    onRouteCalculated?.(routeData);
  };

  // Recherche syst√©matique garantie pour aller-retour (optimis√©e pour rapidit√©)
  const guaranteedRoundTripSearch = async (
    startCoords: [number, number],
    clickCoords: [number, number], 
    targetDistance: number,
    minDistance: number,
    maxDistance: number
  ) => {
    console.log('Starting optimized guaranteed round-trip search...');
    
    // Recherche optimis√©e : seulement 2 niveaux avec moins d'angles
    const searchConfigs = [
      { radius: 0.5, angles: 6, differentiationThreshold: 0.25 }, // Proche - 6 directions
      { radius: 1.2, angles: 8, differentiationThreshold: 0.25 }  // Plus loin - 8 directions
    ];
    
    for (const config of searchConfigs) {
      console.log(`Quick search in ${config.radius}km radius with ${config.angles} directions...`);
      
      // G√©n√©rer les angles uniform√©ment r√©partis
      const angleStep = 360 / config.angles;
      
      for (let i = 0; i < config.angles; i++) {
        const angle = i * angleStep;
        const angleRad = (angle * Math.PI) / 180;
        
        // Une seule distance par angle pour la rapidit√©
        const distance = config.radius;
        const latOffset = (distance * Math.sin(angleRad)) / 111.32;
        const lngOffset = (distance * Math.cos(angleRad)) / (111.32 * Math.cos(clickCoords[1] * Math.PI / 180));
        
        const searchCoords: [number, number] = [
          clickCoords[0] + lngOffset,
          clickCoords[1] + latOffset
        ];
        
        try {
          const outboundRoute = await getRoute(startCoords, searchCoords);
          if (!outboundRoute) continue;
          
          // Essayer avec le seuil de diff√©renciation optimis√©
          const returnRoute = await getRouteWithAlternatives(
            searchCoords, 
            startCoords, 
            outboundRoute, 
            config.differentiationThreshold
          );
          if (!returnRoute) continue;
          
          const totalDistanceKm = (outboundRoute.distance + returnRoute.distance) / 1000;
          
          // Respect strict ¬±5% tolerance
          if (totalDistanceKm >= minDistance && totalDistanceKm <= maxDistance) {
            console.log(`‚úì Found guaranteed round-trip: ${totalDistanceKm.toFixed(2)}km (target: ${targetDistance.toFixed(2)}km)`);
            return {
              destination: searchCoords,
              outboundRoute: outboundRoute,
              returnRoute: returnRoute,
              totalDistance: totalDistanceKm
            };
          }
        } catch (error) {
          continue;
        }
      }
    }
    
    console.log('‚ö†Ô∏è Quick search exhausted, no valid round-trip found');
    return null;
  };

  // Smart route search for round-trip with ¬±5% distance tolerance (completely refactored for speed)
  const findSuitableRoundTripRoute = async (clickedCoords: mapboxgl.LngLat) => {
    if (!planningData || !userLocation) return;
    
    const targetDistance = calculateTargetDistance(planningData.steps, planningData.height);
    const tolerance = 0.05; // 5%
    const minDistance = targetDistance * (1 - tolerance);
    const maxDistance = targetDistance * (1 + tolerance);
    
    setIsCalculating(true);
    setRouteError(null);
    
    const destinationCoords: [number, number] = [clickedCoords.lng, clickedCoords.lat];
    const startCoords: [number, number] = [userLocation.lng, userLocation.lat];
    
    console.log(`Looking for round-trip route: ${minDistance.toFixed(2)}-${maxDistance.toFixed(2)}km`);
    
    try {
      // Strat√©gie 1: Essayer directement le point cliqu√©
      const directResult = await tryDirectRoundTrip(startCoords, destinationCoords, minDistance, maxDistance);
      if (directResult) {
        await displayRoundTripRoute(directResult.destination, directResult.outboundRoute, directResult.returnRoute, directResult.totalDistance);
        onMapClick?.();
        setIsCalculating(false);
        return;
      }
      
      // Strat√©gie 2: Si √©chec, recherche optimis√©e autour du point cliqu√©
      console.log('Direct click failed, trying optimized search...');
      const guaranteedResult = await guaranteedRoundTripSearch(
        startCoords, 
        destinationCoords, 
        targetDistance, 
        minDistance, 
        maxDistance
      );
      
      if (guaranteedResult) {
        await displayRoundTripRoute(guaranteedResult.destination, guaranteedResult.outboundRoute, guaranteedResult.returnRoute, guaranteedResult.totalDistance);
        onMapClick?.();
        setIsCalculating(false);
        return;
      }
      
      // Si tout √©choue
      setRouteError("Impossible de trouver un itin√©raire aller-retour valide. Essayez un autre point sur la carte.");
      setIsCalculating(false);
      
    } catch (error) {
      console.error('Round-trip route error:', error);
      setRouteError("Erreur lors du calcul de l'itin√©raire aller-retour.");
      setIsCalculating(false);
    }
  };
  
  // Fonction optimis√©e pour tenter un aller-retour direct
  const tryDirectRoundTrip = async (
    startCoords: [number, number], 
    destinationCoords: [number, number], 
    minDistance: number, 
    maxDistance: number
  ) => {
    try {
      // Calculer l'itin√©raire aller
      const outboundRoute = await getRoute(startCoords, destinationCoords);
      if (!outboundRoute) return null;
      
      // Essayer directement un retour simple
      const simpleReturnRoute = await getRoute(destinationCoords, startCoords);
      if (simpleReturnRoute) {
        const totalDistanceKm = (outboundRoute.distance + simpleReturnRoute.distance) / 1000;
        
        // V√©rifier si c'est dans la tol√©rance ET si les routes sont suffisamment diff√©rentes
        if (totalDistanceKm >= minDistance && totalDistanceKm <= maxDistance) {
          const overlap = calculatePathOverlap(
            outboundRoute.geometry.coordinates,
            simpleReturnRoute.geometry.coordinates
          );
          
          // Accepter si au moins 20% de diff√©rence (plus tol√©rant pour la vitesse)
          if (overlap < 0.80) {
            console.log(`‚úì Direct round-trip found: ${totalDistanceKm.toFixed(2)}km, ${((1-overlap)*100).toFixed(0)}% different`);
            return {
              destination: destinationCoords,
              outboundRoute: outboundRoute,
              returnRoute: simpleReturnRoute,
              totalDistance: totalDistanceKm
            };
          }
        }
      }
      
      // Si le retour simple ne marche pas, essayer avec alternatives rapides
      const alternativeReturn = await getRouteWithAlternatives(destinationCoords, startCoords, outboundRoute, 0.20);
      if (alternativeReturn) {
        const totalDistanceKm = (outboundRoute.distance + alternativeReturn.distance) / 1000;
        
        if (totalDistanceKm >= minDistance && totalDistanceKm <= maxDistance) {
          console.log(`‚úì Alternative round-trip found: ${totalDistanceKm.toFixed(2)}km`);
          return {
            destination: destinationCoords,
            outboundRoute: outboundRoute,
            returnRoute: alternativeReturn,
            totalDistance: totalDistanceKm
          };
        }
      }
      
      return null;
    } catch (error) {
      return null;
    }
  };

  // Recherche √©largie de destination
  const expandedDestinationSearch = async (
    startCoords: [number, number],
    clickCoords: [number, number], 
    targetDistance: number,
    minDistance: number,
    maxDistance: number
  ) => {
    // Rayons de recherche progressifs (en km)
    const searchRadiuses = [0.5, 1.0, 1.5, 2.0];
    const searchAngles = [0, 45, 90, 135, 180, 225, 270, 315]; // Directions en degr√©s
    
    for (const radius of searchRadiuses) {
      console.log(`Searching in ${radius}km radius around click point...`);
      
      for (const angle of searchAngles) {
        // Convertir l'angle en radians
        const angleRad = (angle * Math.PI) / 180;
        
        // Calculer les coordonn√©es du point de recherche
        const latOffset = (radius * Math.sin(angleRad)) / 111.32;
        const lngOffset = (radius * Math.cos(angleRad)) / (111.32 * Math.cos(clickCoords[1] * Math.PI / 180));
        
        const searchCoords: [number, number] = [
          clickCoords[0] + lngOffset,
          clickCoords[1] + latOffset
        ];
        
        try {
          const route = await getRoute(startCoords, searchCoords);
          if (!route) continue;
          
          const distanceKm = route.distance / 1000;
          
          // V√©rifier si la distance respecte la tol√©rance souhait√©e (¬±5%)
          if (distanceKm >= minDistance && distanceKm <= maxDistance) {
            console.log(`Found suitable destination at ${radius}km radius: ${distanceKm.toFixed(2)}km`);
            return {
              destination: searchCoords,
              route: route,
              distance: distanceKm
            };
          }
        } catch (error) {
          console.log(`Failed to get route for search point at angle ${angle}`);
          continue;
        }
      }
    }
    
    return null;
  };

  // Handle map click for destination selection
  const handleMapClick = async (e: mapboxgl.MapMouseEvent) => {
    // D√©sactiver les clics si on est en mode r√©initialis√©
    if (!planningData || !userLocation || isCalculating || !canClick || isReset) return;
    
    setIsManualSelection(true);
    
    if (planningData.tripType === 'one-way') {
      // Handle one-way route with smart search
      const targetDistance = calculateTargetDistance(planningData.steps, planningData.height);
      const tolerance = 0.05; // 5%
      const minDistance = targetDistance * (1 - tolerance);
      const maxDistance = targetDistance * (1 + tolerance);
      const clickTolerance = 0.30; // 300m tolerance for accepting clicks

      setIsCalculating(true);
      setRouteError(null);

      const destinationCoords: [number, number] = [e.lngLat.lng, e.lngLat.lat];
      const startCoords: [number, number] = [userLocation.lng, userLocation.lat];

      const route = await getRoute(startCoords, destinationCoords);
      
      if (!route) {
        setRouteError("Impossible de calculer l'itin√©raire.");
        setIsCalculating(false);
        return;
      }

      const initialDistanceKm = route.distance / 1000;
      
      // Check if we're within click tolerance (¬±300m)
      if (Math.abs(initialDistanceKm - targetDistance) > clickTolerance) {
        console.log(`Initial click outside tolerance. Starting expanded search...`);
        
        // Mode "recherche √©largie" - chercher automatiquement dans un rayon plus large
        const expandedSearchResult = await expandedDestinationSearch(
          startCoords, 
          destinationCoords, 
          targetDistance, 
          minDistance, 
          maxDistance
        );
        
        if (!expandedSearchResult) {
          setRouteError(`Aucune destination trouv√©e dans la zone √©largie (~${targetDistance.toFixed(1)}km ¬±5%). Essayez un autre point.`);
          setIsCalculating(false);
          return;
        }
        
        await displayRoute(expandedSearchResult.destination, expandedSearchResult.route, expandedSearchResult.distance);
        onMapClick?.();
        setIsCalculating(false);
        return;
      }

      // If already within ¬±5% tolerance, use as-is
      if (initialDistanceKm >= minDistance && initialDistanceKm <= maxDistance) {
        await displayRoute(destinationCoords, route, initialDistanceKm);
        
        // Increment attempts only when a valid route is found
        onMapClick?.();
        
        setIsCalculating(false);
        return;
      }

      // Need to adjust: calculate direction and adjust distance to fit within ¬±5% range
      console.log(`Initial distance ${initialDistanceKm.toFixed(2)}km outside ¬±5% range. Adjusting...`);
      
      // Calculate direction from user to clicked point
      const bearing = Math.atan2(
        destinationCoords[1] - startCoords[1], 
        destinationCoords[0] - startCoords[0]
      );

      // Determine target distance within acceptable range
      let adjustedTargetDistance;
      if (initialDistanceKm < minDistance) {
        // Too short, aim for minimum acceptable distance
        adjustedTargetDistance = minDistance;
      } else {
        // Too long, aim for maximum acceptable distance
        adjustedTargetDistance = maxDistance;
      }

      // Calculate adjusted destination coordinates
      // Convert km to approximate degrees (rough approximation)
      const latOffset = (adjustedTargetDistance * Math.sin(bearing)) / 111.32; // 1 degree lat ‚âà 111.32 km
      const lngOffset = (adjustedTargetDistance * Math.cos(bearing)) / (111.32 * Math.cos(userLocation.lat * Math.PI / 180));
      
      const adjustedDestination: [number, number] = [
        startCoords[0] + lngOffset,
        startCoords[1] + latOffset
      ];

      // Calculate route to adjusted destination
      const adjustedRoute = await getRoute(startCoords, adjustedDestination);
      
      if (!adjustedRoute) {
        setRouteError("Impossible de calculer l'itin√©raire ajust√©.");
        setIsCalculating(false);
        return;
      }

      const finalDistanceKm = adjustedRoute.distance / 1000;
      console.log(`Adjusted to ${finalDistanceKm.toFixed(2)}km (target range: ${minDistance.toFixed(2)}-${maxDistance.toFixed(2)}km)`);

      // Verify that the final route distance is still within ¬±5% tolerance
      if (finalDistanceKm < minDistance || finalDistanceKm > maxDistance) {
        setRouteError(`Impossible d'ajuster l'itin√©raire dans la tol√©rance ¬±5% (${finalDistanceKm.toFixed(2)}km). Essayez un autre point.`);
        setIsCalculating(false);
        return;
      }

      await displayRoute(adjustedDestination, adjustedRoute, finalDistanceKm);
      
      // Increment attempts only when a valid route is found
      onMapClick?.();
      
      setIsCalculating(false);
    } else if (planningData.tripType === 'round-trip') {
      // Handle round-trip route with smart search
      await findSuitableRoundTripRoute(e.lngLat);
    }
  };

  // Get Mapbox token
  useEffect(() => {
    const fetchToken = async () => {
      try {
        const { supabase } = await import('@/integrations/supabase/client');
        const { data, error } = await supabase.functions.invoke('mapbox-token');
        
        if (error) throw error;
        if (data?.token) {
          setMapboxToken(data.token);
        }
      } catch (error) {
        console.error('Error fetching Mapbox token:', error);
      }
    };
    fetchToken();
  }, []);

  // Get user location
  useEffect(() => {
    if (navigator.geolocation) {
      navigator.geolocation.getCurrentPosition(
        (position) => {
          setUserLocation({
            lat: position.coords.latitude,
            lng: position.coords.longitude
          });
        },
        (error) => {
          console.error('Geolocation error:', error);
          setPermissionDenied(true);
          // Center on France if geolocation is denied
          setUserLocation({ lat: 46.603354, lng: 1.888334 });
        }
      );
    } else {
      // Center on France if geolocation is not available
      setUserLocation({ lat: 46.603354, lng: 1.888334 });
    }
  }, []);

  // Initialize map
  useEffect(() => {
    if (!mapContainer.current || !mapboxToken || !userLocation || map.current) return;

    mapboxgl.accessToken = mapboxToken;
    
    map.current = new mapboxgl.Map({
      container: mapContainer.current,
      style: 'mapbox://styles/mapbox/streets-v12',
      center: [userLocation.lng, userLocation.lat],
      zoom: 13
    });

    // Add navigation controls (zoom, rotate, compass)
    map.current.addControl(new mapboxgl.NavigationControl(), 'top-right');

    // Add geolocate control to find user location
    const geolocateControl = new mapboxgl.GeolocateControl({
      positionOptions: {
        enableHighAccuracy: true
      },
      trackUserLocation: false,
      showUserHeading: true
    });
    map.current.addControl(geolocateControl, 'top-right');

    // Add user marker (green) if geolocation was successful
    if (!permissionDenied) {
      userMarker.current = new mapboxgl.Marker({ color: '#10b981' })
        .setLngLat([userLocation.lng, userLocation.lat])
        .addTo(map.current);
    }

    // Add click handler for both one-way and round-trip routes (if clicks are allowed)
    if (planningData && canClick) {
      map.current.on('click', handleMapClick);
    }

    return () => {
      map.current?.remove();
    };
  }, [mapboxToken, userLocation, permissionDenied, planningData]);

  // Auto-generate route for one-way and round-trip
  useEffect(() => {
    if (map.current && planningData && userLocation && mapboxToken && !hasAutoGenerated && !isCalculating) {
      if (planningData.tripType === 'one-way') {
        console.log('Auto-generating random destination for one-way trip...');
        generateRandomDestination();
      } else if (planningData.tripType === 'round-trip') {
        console.log('Auto-generating round-trip route...');
        generateRoundTripDestination();
      }
    }
  }, [map.current, planningData, userLocation, mapboxToken, hasAutoGenerated, isCalculating]);

  // Fonction utilitaire pour restaurer une route sur la carte
  const restoreRouteDisplay = (routeData: any) => {
    if (!map.current || !routeData) return;
    
    // Supprimer la route existante
    if (map.current.getSource('route')) {
      map.current.removeLayer('route');
      map.current.removeSource('route');
    }
    
    // Restaurer le marqueur de destination
    if (destinationMarker.current) {
      destinationMarker.current.remove();
    }
    destinationMarker.current = new mapboxgl.Marker({ color: '#ef4444' })
      .setLngLat([routeData.endCoordinates.lng, routeData.endCoordinates.lat])
      .addTo(map.current);
    
    // Ajouter la source et la couche de route
    const isRoundTrip = routeData.routeGeoJSON.type === 'FeatureCollection';
    
    map.current.addSource('route', {
      type: 'geojson',
      data: isRoundTrip 
        ? routeData.routeGeoJSON 
        : { type: 'Feature', properties: {}, geometry: routeData.routeGeoJSON }
    });
    
    if (isRoundTrip) {
      map.current.addLayer({
        id: 'route',
        type: 'line',
        source: 'route',
        layout: { 'line-join': 'round', 'line-cap': 'round' },
        paint: {
          'line-color': ['case', ['==', ['get', 'type'], 'outbound'], '#10b981', '#3b82f6'],
          'line-width': 4,
          'line-dasharray': ['case', ['==', ['get', 'type'], 'return'], [2, 2], [1, 0]]
        }
      });
    } else {
      map.current.addLayer({
        id: 'route',
        type: 'line',
        source: 'route',
        layout: { 'line-join': 'round', 'line-cap': 'round' },
        paint: { 'line-color': '#3b82f6', 'line-width': 4 }
      });
    }
    
    // Ajuster la vue
    const coordinates = isRoundTrip 
      ? routeData.routeGeoJSON.features.flatMap((f: any) => f.geometry.coordinates)
      : routeData.routeGeoJSON.coordinates;
    
    if (coordinates?.length > 0) {
      const bounds = coordinates.reduce((bounds: any, coord: any) => {
        return bounds.extend(coord);
      }, new mapboxgl.LngLatBounds(coordinates[0], coordinates[0]));
      
      map.current.fitBounds(bounds, { padding: 50 });
    }
  };

  // Handle forced reset to default route
  useEffect(() => {
    if (!forceReset) return;
    
    console.log('R√©initialisation en cours...');
    setIsManualSelection(false);
    setRouteError(null);
    setIsReset(true);
    
    if (firstRouteData) {
      console.log('Restauration du premier itin√©raire');
      onRouteCalculated?.(firstRouteData);
      restoreRouteDisplay(firstRouteData);
    } else {
      console.log('G√©n√©ration d\'un nouvel itin√©raire par d√©faut');
      setHasAutoGenerated(false);
      if (planningData?.tripType === 'one-way') {
        generateRandomDestination();
      } else if (planningData?.tripType === 'round-trip') {
        generateRoundTripDestination();
      }
    }
    
    onResetComplete?.();
  }, [forceReset]);

  if (!mapboxToken) {
    return (
      <div className={`w-full h-[500px] bg-muted rounded-2xl flex items-center justify-center ${className}`}>
        <div className="text-center p-8">
          <div className="animate-spin rounded-full h-8 w-8 border-b-2 border-primary mx-auto mb-4"></div>
          <p className="text-muted-foreground">Chargement de la carte...</p>
        </div>
      </div>
    );
  }

  return (
    <div className={`w-full h-[500px] rounded-2xl shadow-lg relative ${className}`}>
      <div ref={mapContainer} className="w-full h-full rounded-2xl" />
      
      {/* Custom Refit to Route Button */}
      {hasAutoGenerated && (
        <button
          onClick={() => {
            if (map.current) {
              // Re-fit the map to show the current route
              const currentRoute = planningData?.tripType === 'round-trip' 
                ? map.current.getSource('outbound-route') || map.current.getSource('route')
                : map.current.getSource('route');
              
              if (currentRoute) {
                // Get bounds from current route and destination
                if (userLocation && destinationMarker.current) {
                  const bounds = new mapboxgl.LngLatBounds();
                  bounds.extend([userLocation.lng, userLocation.lat]);
                  bounds.extend(destinationMarker.current.getLngLat());
                  
                  map.current.fitBounds(bounds, {
                    padding: 80,
                    duration: 1000
                  });
                }
              }
            }
          }}
          className="absolute top-4 left-4 bg-card/90 backdrop-blur-sm hover:bg-card text-foreground p-2 rounded-lg shadow-lg transition-all hover:scale-105"
          title="Recentrer sur l'itin√©raire"
        >
          <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round">
            <path d="M3 7V5a2 2 0 0 1 2-2h2"></path>
            <path d="M17 3h2a2 2 0 0 1 2 2v2"></path>
            <path d="M21 17v2a2 2 0 0 1-2 2h-2"></path>
            <path d="M7 21H5a2 2 0 0 1-2-2v-2"></path>
            <path d="M12 12l-3-3m0 0l3-3m-3 3h12"></path>
          </svg>
        </button>
      )}
      
      {/* Route Error Display */}
      {routeError && (
        <div className="absolute top-4 left-4 right-4 bg-destructive/90 backdrop-blur-sm text-destructive-foreground p-3 rounded-lg shadow-lg">
          <p className="text-sm font-medium">{routeError}</p>
        </div>
      )}
      
      {/* Calculating Indicator */}
      {isCalculating && (
        <div className="absolute inset-0 bg-background/50 backdrop-blur-sm rounded-2xl flex items-center justify-center">
          <div className="bg-card p-4 rounded-lg shadow-lg flex items-center space-x-3">
            <div className="animate-spin rounded-full h-5 w-5 border-b-2 border-primary"></div>
            <p className="text-sm font-medium">Calcul de l'itin√©raire...</p>
          </div>
        </div>
      )}
      
      {/* Message pour mode r√©initialis√© */}
      {planningData && isReset && (
        <div className="absolute bottom-4 left-4 right-4 bg-amber-50/90 backdrop-blur-sm p-3 rounded-lg shadow-lg border border-amber-200">
          <p className="text-sm text-center text-amber-800">
            ‚úì Premier itin√©raire restaur√© ‚Ä¢ Clics d√©sactiv√©s apr√®s r√©initialisation
          </p>
        </div>
      )}
      
      {/* Instructions */}
      {planningData && planningData.tripType === 'one-way' && !routeError && !isCalculating && hasAutoGenerated && canClick && !isManualSelection && !isReset && (
        <div className="absolute bottom-4 left-4 right-4 bg-card/90 backdrop-blur-sm p-3 rounded-lg shadow-lg">
          <p className="text-sm text-center text-muted-foreground">
            Itin√©raire g√©n√©r√© automatiquement ‚Ä¢ Cliquez pour changer de destination
          </p>
        </div>
      )}
      
      {planningData && planningData.tripType === 'one-way' && !routeError && !isCalculating && hasAutoGenerated && !canClick && !isReset && (
        <div className="absolute bottom-4 left-4 right-4 bg-card/90 backdrop-blur-sm p-3 rounded-lg shadow-lg">
          <p className="text-sm text-center text-muted-foreground">
            {isManualSelection ? 'Destination s√©lectionn√©e ‚Ä¢ Plus de clics possibles' : 'Itin√©raire par d√©faut ‚Ä¢ Plus de clics possibles'}
          </p>
        </div>
      )}
      
      {planningData && planningData.tripType === 'one-way' && !routeError && !isCalculating && hasAutoGenerated && canClick && isManualSelection && !isReset && (
        <div className="absolute bottom-4 left-4 right-4 bg-card/90 backdrop-blur-sm p-3 rounded-lg shadow-lg">
          <p className="text-sm text-center text-muted-foreground">
            Destination s√©lectionn√©e ‚Ä¢ Cliquez pour en choisir une autre
          </p>
        </div>
      )}
      
      {planningData && planningData.tripType === 'one-way' && !routeError && !isCalculating && !hasAutoGenerated && !isReset && (
        <div className="absolute bottom-4 left-4 right-4 bg-card/90 backdrop-blur-sm p-3 rounded-lg shadow-lg">
          <p className="text-sm text-center text-muted-foreground">
            G√©n√©ration automatique d'un itin√©raire en cours...
          </p>
        </div>
      )}

      {planningData && planningData.tripType === 'round-trip' && !routeError && !isCalculating && hasAutoGenerated && !isReset && (
        <div className="absolute bottom-4 left-4 right-4 bg-card/90 backdrop-blur-sm p-3 rounded-lg shadow-lg">
          <p className="text-sm text-center text-muted-foreground">
            Itin√©raire aller-retour g√©n√©r√© ‚Ä¢ <span className="text-green-600">Vert</span>: aller ‚Ä¢ <span className="text-blue-600">Bleu pointill√©</span>: retour
          </p>
        </div>
      )}
      
      {planningData && planningData.tripType === 'round-trip' && !routeError && !isCalculating && !hasAutoGenerated && !isReset && (
        <div className="absolute bottom-4 left-4 right-4 bg-card/90 backdrop-blur-sm p-3 rounded-lg shadow-lg">
          <p className="text-sm text-center text-muted-foreground">
            G√©n√©ration automatique d'un itin√©raire aller-retour...
          </p>
        </div>
      )}
    </div>
  );
};

export default EnhancedMap;