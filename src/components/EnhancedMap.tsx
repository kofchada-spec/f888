import React, { useEffect, useRef, useState } from 'react';
import mapboxgl from 'mapbox-gl';
import 'mapbox-gl/dist/mapbox-gl.css';

interface PlanningData {
  steps: string;
  pace: 'slow' | 'moderate' | 'fast';
  tripType: 'one-way' | 'round-trip';
  height: string;
  weight: string;
}

interface EnhancedMapProps {
  className?: string;
  planningData?: PlanningData;
  onRouteCalculated?: (data: {
    distance: number;
    duration: number;
    calories: number;
    steps: number;
    startCoordinates: { lat: number; lng: number };
    endCoordinates: { lat: number; lng: number };
    routeGeoJSON?: any;
  }) => void;
}

const EnhancedMap: React.FC<EnhancedMapProps> = ({ 
  className = '', 
  planningData, 
  onRouteCalculated 
}) => {
  const mapContainer = useRef<HTMLDivElement>(null);
  const map = useRef<mapboxgl.Map | null>(null);
  const userMarker = useRef<mapboxgl.Marker | null>(null);
  const destinationMarker = useRef<mapboxgl.Marker | null>(null);
  
  const [mapboxToken, setMapboxToken] = useState<string | null>(null);
  const [userLocation, setUserLocation] = useState<{ lat: number; lng: number } | null>(null);
  const [permissionDenied, setPermissionDenied] = useState(false);
  const [routeError, setRouteError] = useState<string | null>(null);
  const [isCalculating, setIsCalculating] = useState(false);
  const [hasAutoGenerated, setHasAutoGenerated] = useState(false);

  // Calculate target distance from steps and height
  const calculateTargetDistance = (steps: string, height: string) => {
    const stepCount = parseInt(steps);
    const heightInMeters = parseFloat(height);
    const strideLength = 0.415 * heightInMeters;
    return (stepCount * strideLength) / 1000; // km
  };

  // Calculate calories based on distance, weight, and pace
  const calculateCalories = (distanceKm: number, weight: string, pace: string) => {
    const weightKg = parseFloat(weight);
    const met = pace === 'slow' ? 3.0 : pace === 'moderate' ? 4.0 : 5.0;
    const timeHours = distanceKm / (pace === 'slow' ? 4 : pace === 'moderate' ? 5 : 6);
    return Math.round(met * weightKg * timeHours);
  };

  // Get route from Mapbox Directions API
  const getRoute = async (start: [number, number], end: [number, number]) => {
    if (!mapboxToken) return null;
    
    try {
      const response = await fetch(
        `https://api.mapbox.com/directions/v5/mapbox/walking/${start[0]},${start[1]};${end[0]},${end[1]}?geometries=geojson&access_token=${mapboxToken}`
      );
      
      if (!response.ok) throw new Error('Failed to fetch route');
      
      const data = await response.json();
      return data.routes[0];
    } catch (error) {
      console.error('Route fetch error:', error);
      return null;
    }
  };

  // Generate automatic random destination for one-way routes
  const generateRandomDestination = async () => {
    if (!planningData || !userLocation || planningData.tripType !== 'one-way') return;

    const targetDistance = calculateTargetDistance(planningData.steps, planningData.height);
    const tolerance = 0.05; // 5%
    const minDistance = targetDistance * (1 - tolerance);
    const maxDistance = targetDistance * (1 + tolerance);

    setIsCalculating(true);
    setRouteError(null);

    // Try multiple random destinations around user location
    const maxAttempts = 10;
    for (let i = 0; i < maxAttempts; i++) {
      // Generate random point within reasonable radius (roughly targetDistance * 1.2)
      const maxRadius = targetDistance * 1.2;
      const angle = Math.random() * 2 * Math.PI;
      const radius = Math.random() * maxRadius;
      
      // Convert km to approximate degrees (rough approximation)
      const latOffset = (radius * Math.cos(angle)) / 111.32; // 1 degree lat ≈ 111.32 km
      const lngOffset = (radius * Math.sin(angle)) / (111.32 * Math.cos(userLocation.lat * Math.PI / 180));
      
      const destinationCoords: [number, number] = [
        userLocation.lng + lngOffset,
        userLocation.lat + latOffset
      ];
      
      const startCoords: [number, number] = [userLocation.lng, userLocation.lat];
      const route = await getRoute(startCoords, destinationCoords);
      
      if (route) {
        const routeDistanceKm = route.distance / 1000;
        
        if (routeDistanceKm >= minDistance && routeDistanceKm <= maxDistance) {
          // Found a valid route!
          await displayRoute(destinationCoords, route, routeDistanceKm);
          setHasAutoGenerated(true);
          setIsCalculating(false);
          return;
        }
      }
    }

    // No valid route found within tolerance
    setRouteError(`Aucun itinéraire trouvé dans la tolérance de ±5% (cible: ${targetDistance.toFixed(2)}km).`);
    setIsCalculating(false);
  };

  // Generate automatic round-trip route with different outbound and return paths
  const generateRoundTripDestination = async () => {
    if (!planningData || !userLocation || planningData.tripType !== 'round-trip') return;

    const targetDistance = calculateTargetDistance(planningData.steps, planningData.height);
    const tolerance = 0.05; // 5%
    const minDistance = targetDistance * (1 - tolerance);
    const maxDistance = targetDistance * (1 + tolerance);

    setIsCalculating(true);
    setRouteError(null);

    // Try multiple random destinations for round-trip
    const maxAttempts = 15;
    for (let i = 0; i < maxAttempts; i++) {
      // Generate random point within reasonable radius (roughly targetDistance * 0.6 for half distance)
      const maxRadius = targetDistance * 0.6;
      const angle = Math.random() * 2 * Math.PI;
      const radius = Math.random() * maxRadius;
      
      // Convert km to approximate degrees
      const latOffset = (radius * Math.cos(angle)) / 111.32;
      const lngOffset = (radius * Math.sin(angle)) / (111.32 * Math.cos(userLocation.lat * Math.PI / 180));
      
      const destinationCoords: [number, number] = [
        userLocation.lng + lngOffset,
        userLocation.lat + latOffset
      ];
      
      const startCoords: [number, number] = [userLocation.lng, userLocation.lat];
      
      // Get outbound route
      const outboundRoute = await getRoute(startCoords, destinationCoords);
      if (!outboundRoute) continue;
      
      // Get return route with alternatives parameter to get different path
      const returnRoute = await getRouteWithAlternatives(destinationCoords, startCoords);
      if (!returnRoute) continue;
      
      const totalDistanceKm = (outboundRoute.distance + returnRoute.distance) / 1000;
      
      if (totalDistanceKm >= minDistance && totalDistanceKm <= maxDistance) {
        // Found valid round-trip routes!
        await displayRoundTripRoute(destinationCoords, outboundRoute, returnRoute, totalDistanceKm);
        setHasAutoGenerated(true);
        setIsCalculating(false);
        return;
      }
    }

    // No valid round-trip found within tolerance  
    setRouteError(`Aucun itinéraire aller-retour trouvé dans la tolérance de ±5% (cible: ${targetDistance.toFixed(2)}km).`);
    setIsCalculating(false);
  };

  // Get route with alternatives to ensure different return path
  const getRouteWithAlternatives = async (start: [number, number], end: [number, number]) => {
    if (!mapboxToken) return null;
    
    try {
      const response = await fetch(
        `https://api.mapbox.com/directions/v5/mapbox/walking/${start[0]},${start[1]};${end[0]},${end[1]}?geometries=geojson&alternatives=true&access_token=${mapboxToken}`
      );
      
      if (!response.ok) throw new Error('Failed to fetch route');
      
      const data = await response.json();
      // Return the alternative route if available, otherwise the main route
      return data.routes[1] || data.routes[0];
    } catch (error) {
      console.error('Route fetch error:', error);
      return null;
    }
  };

  // Display route on map
  const displayRoute = async (destinationCoords: [number, number], route: any, routeDistanceKm: number) => {
    if (!planningData || !userLocation) return;

    // Remove existing destination marker
    if (destinationMarker.current) {
      destinationMarker.current.remove();
    }

    // Add destination marker (red)
    destinationMarker.current = new mapboxgl.Marker({ color: '#ef4444' })
      .setLngLat(destinationCoords)
      .addTo(map.current!);

    // Add route to map
    if (map.current?.getSource('route')) {
      map.current.removeLayer('route');
      map.current.removeSource('route');
    }

    map.current?.addSource('route', {
      type: 'geojson',
      data: {
        type: 'Feature',
        properties: {},
        geometry: route.geometry
      }
    });

    map.current?.addLayer({
      id: 'route',
      type: 'line',
      source: 'route',
      layout: {
        'line-join': 'round',
        'line-cap': 'round'
      },
      paint: {
        'line-color': '#3b82f6',
        'line-width': 4
      }
    });

    // Fit map to route bounds
    const coordinates = route.geometry.coordinates;
    const bounds = coordinates.reduce((bounds: any, coord: any) => {
      return bounds.extend(coord);
    }, new mapboxgl.LngLatBounds(coordinates[0], coordinates[0]));
    
    map.current?.fitBounds(bounds, {
      padding: 50
    });

    // Calculate route data
    const calories = calculateCalories(routeDistanceKm, planningData.weight, planningData.pace);
    const durationMin = Math.round(route.duration / 60);
    const steps = parseInt(planningData.steps);

    const routeData = {
      distance: routeDistanceKm,
      duration: durationMin,
      calories,
      steps,
      startCoordinates: { lat: userLocation.lat, lng: userLocation.lng },
      endCoordinates: { lat: destinationCoords[1], lng: destinationCoords[0] },
      routeGeoJSON: route.geometry
    };

    onRouteCalculated?.(routeData);
  };

  // Display round-trip route with different outbound and return paths
  const displayRoundTripRoute = async (destinationCoords: [number, number], outboundRoute: any, returnRoute: any, totalDistanceKm: number) => {
    if (!planningData || !userLocation) return;

    // Remove existing markers and routes
    if (destinationMarker.current) {
      destinationMarker.current.remove();
    }

    // Remove existing routes
    if (map.current?.getSource('outbound-route')) {
      map.current.removeLayer('outbound-route');
      map.current.removeSource('outbound-route');
    }
    if (map.current?.getSource('return-route')) {
      map.current.removeLayer('return-route');
      map.current.removeSource('return-route');
    }
    if (map.current?.getSource('route')) {
      map.current.removeLayer('route');
      map.current.removeSource('route');
    }

    // Update user marker to green
    if (userMarker.current) {
      userMarker.current.remove();
    }
    userMarker.current = new mapboxgl.Marker({ color: '#10b981' })
      .setLngLat([userLocation.lng, userLocation.lat])
      .addTo(map.current!);

    // Add destination marker (red)
    destinationMarker.current = new mapboxgl.Marker({ color: '#ef4444' })
      .setLngLat(destinationCoords)
      .addTo(map.current!);

    // Add outbound route (solid green)
    map.current?.addSource('outbound-route', {
      type: 'geojson',
      data: {
        type: 'Feature',
        properties: {},
        geometry: outboundRoute.geometry
      }
    });

    map.current?.addLayer({
      id: 'outbound-route',
      type: 'line',
      source: 'outbound-route',
      layout: {
        'line-join': 'round',
        'line-cap': 'round'
      },
      paint: {
        'line-color': '#10b981',
        'line-width': 4
      }
    });

    // Add return route (dashed blue)
    map.current?.addSource('return-route', {
      type: 'geojson',
      data: {
        type: 'Feature',
        properties: {},
        geometry: returnRoute.geometry
      }
    });

    map.current?.addLayer({
      id: 'return-route',
      type: 'line',
      source: 'return-route',
      layout: {
        'line-join': 'round',
        'line-cap': 'round'
      },
      paint: {
        'line-color': '#3b82f6',
        'line-width': 4,
        'line-dasharray': [2, 2]
      }
    });

    // Fit map to both routes bounds
    const allCoordinates = [...outboundRoute.geometry.coordinates, ...returnRoute.geometry.coordinates];
    const bounds = allCoordinates.reduce((bounds: any, coord: any) => {
      return bounds.extend(coord);
    }, new mapboxgl.LngLatBounds(allCoordinates[0], allCoordinates[0]));
    
    map.current?.fitBounds(bounds, {
      padding: 50
    });

    // Calculate route data
    const calories = calculateCalories(totalDistanceKm, planningData.weight, planningData.pace);
    const durationMin = Math.round((outboundRoute.duration + returnRoute.duration) / 60);
    const steps = parseInt(planningData.steps);

    const routeData = {
      distance: totalDistanceKm,
      duration: durationMin,
      calories,
      steps,
      startCoordinates: { lat: userLocation.lat, lng: userLocation.lng },
      endCoordinates: { lat: destinationCoords[1], lng: destinationCoords[0] },
      routeGeoJSON: {
        type: 'FeatureCollection',
        features: [
          { type: 'Feature', properties: { type: 'outbound' }, geometry: outboundRoute.geometry },
          { type: 'Feature', properties: { type: 'return' }, geometry: returnRoute.geometry }
        ]
      }
    };

    onRouteCalculated?.(routeData);
  };

  // Handle map click for destination selection
  const handleMapClick = async (e: mapboxgl.MapMouseEvent) => {
    if (!planningData || !userLocation || isCalculating) return;

    const targetDistance = calculateTargetDistance(planningData.steps, planningData.height);
    const tolerance = 0.05; // 5%
    const minDistance = targetDistance * (1 - tolerance);
    const maxDistance = targetDistance * (1 + tolerance);

    setIsCalculating(true);
    setRouteError(null);

    const destinationCoords: [number, number] = [e.lngLat.lng, e.lngLat.lat];
    const startCoords: [number, number] = [userLocation.lng, userLocation.lat];

    const route = await getRoute(startCoords, destinationCoords);
    
    if (!route) {
      setRouteError("Impossible de calculer l'itinéraire.");
      setIsCalculating(false);
      return;
    }

    const routeDistanceKm = route.distance / 1000;
    
    if (routeDistanceKm < minDistance || routeDistanceKm > maxDistance) {
      setRouteError(`Itinéraire hors de portée (${routeDistanceKm.toFixed(2)}km). Distance cible: ${targetDistance.toFixed(2)}km (±5%).`);
      setIsCalculating(false);
      return;
    }

    await displayRoute(destinationCoords, route, routeDistanceKm);
    setIsCalculating(false);
  };

  // Get Mapbox token
  useEffect(() => {
    const fetchToken = async () => {
      try {
        const { supabase } = await import('@/integrations/supabase/client');
        const { data, error } = await supabase.functions.invoke('mapbox-token');
        
        if (error) throw error;
        if (data?.token) {
          setMapboxToken(data.token);
        }
      } catch (error) {
        console.error('Error fetching Mapbox token:', error);
      }
    };
    fetchToken();
  }, []);

  // Get user location
  useEffect(() => {
    if (navigator.geolocation) {
      navigator.geolocation.getCurrentPosition(
        (position) => {
          setUserLocation({
            lat: position.coords.latitude,
            lng: position.coords.longitude
          });
        },
        (error) => {
          console.error('Geolocation error:', error);
          setPermissionDenied(true);
          // Center on France if geolocation is denied
          setUserLocation({ lat: 46.603354, lng: 1.888334 });
        }
      );
    } else {
      // Center on France if geolocation is not available
      setUserLocation({ lat: 46.603354, lng: 1.888334 });
    }
  }, []);

  // Initialize map
  useEffect(() => {
    if (!mapContainer.current || !mapboxToken || !userLocation || map.current) return;

    mapboxgl.accessToken = mapboxToken;
    
    map.current = new mapboxgl.Map({
      container: mapContainer.current,
      style: 'mapbox://styles/mapbox/streets-v12',
      center: [userLocation.lng, userLocation.lat],
      zoom: 13
    });

    // Add user marker (green) if geolocation was successful
    if (!permissionDenied) {
      userMarker.current = new mapboxgl.Marker({ color: '#10b981' })
        .setLngLat([userLocation.lng, userLocation.lat])
        .addTo(map.current);
    }

    // Add click handler for one-way routes only
    if (planningData && planningData.tripType === 'one-way') {
      map.current.on('click', handleMapClick);
    }

    return () => {
      map.current?.remove();
    };
  }, [mapboxToken, userLocation, permissionDenied, planningData]);

  // Auto-generate route for one-way and round-trip
  useEffect(() => {
    if (map.current && planningData && userLocation && mapboxToken && !hasAutoGenerated && !isCalculating) {
      if (planningData.tripType === 'one-way') {
        console.log('Auto-generating random destination for one-way trip...');
        generateRandomDestination();
      } else if (planningData.tripType === 'round-trip') {
        console.log('Auto-generating round-trip route...');
        generateRoundTripDestination();
      }
    }
  }, [map.current, planningData, userLocation, mapboxToken, hasAutoGenerated, isCalculating]);

  if (!mapboxToken) {
    return (
      <div className={`w-full h-[500px] bg-muted rounded-2xl flex items-center justify-center ${className}`}>
        <div className="text-center p-8">
          <div className="animate-spin rounded-full h-8 w-8 border-b-2 border-primary mx-auto mb-4"></div>
          <p className="text-muted-foreground">Chargement de la carte...</p>
        </div>
      </div>
    );
  }

  return (
    <div className={`w-full h-[500px] rounded-2xl shadow-lg relative ${className}`}>
      <div ref={mapContainer} className="w-full h-full rounded-2xl" />
      
      {/* Route Error Display */}
      {routeError && (
        <div className="absolute top-4 left-4 right-4 bg-destructive/90 backdrop-blur-sm text-destructive-foreground p-3 rounded-lg shadow-lg">
          <p className="text-sm font-medium">{routeError}</p>
        </div>
      )}
      
      {/* Calculating Indicator */}
      {isCalculating && (
        <div className="absolute inset-0 bg-background/50 backdrop-blur-sm rounded-2xl flex items-center justify-center">
          <div className="bg-card p-4 rounded-lg shadow-lg flex items-center space-x-3">
            <div className="animate-spin rounded-full h-5 w-5 border-b-2 border-primary"></div>
            <p className="text-sm font-medium">Calcul de l'itinéraire...</p>
          </div>
        </div>
      )}
      
      {/* Instructions */}
      {planningData && planningData.tripType === 'one-way' && !routeError && !isCalculating && hasAutoGenerated && (
        <div className="absolute bottom-4 left-4 right-4 bg-card/90 backdrop-blur-sm p-3 rounded-lg shadow-lg">
          <p className="text-sm text-center text-muted-foreground">
            Itinéraire généré automatiquement • Cliquez pour changer de destination
          </p>
        </div>
      )}
      
      {planningData && planningData.tripType === 'one-way' && !routeError && !isCalculating && !hasAutoGenerated && (
        <div className="absolute bottom-4 left-4 right-4 bg-card/90 backdrop-blur-sm p-3 rounded-lg shadow-lg">
          <p className="text-sm text-center text-muted-foreground">
            Génération automatique d'un itinéraire en cours...
          </p>
        </div>
      )}

      {planningData && planningData.tripType === 'round-trip' && !routeError && !isCalculating && hasAutoGenerated && (
        <div className="absolute bottom-4 left-4 right-4 bg-card/90 backdrop-blur-sm p-3 rounded-lg shadow-lg">
          <p className="text-sm text-center text-muted-foreground">
            Itinéraire aller-retour généré • <span className="text-green-600">Vert</span>: aller • <span className="text-blue-600">Bleu pointillé</span>: retour
          </p>
        </div>
      )}
      
      {planningData && planningData.tripType === 'round-trip' && !routeError && !isCalculating && !hasAutoGenerated && (
        <div className="absolute bottom-4 left-4 right-4 bg-card/90 backdrop-blur-sm p-3 rounded-lg shadow-lg">
          <p className="text-sm text-center text-muted-foreground">
            Génération automatique d'un itinéraire aller-retour...
          </p>
        </div>
      )}
    </div>
  );
};

export default EnhancedMap;